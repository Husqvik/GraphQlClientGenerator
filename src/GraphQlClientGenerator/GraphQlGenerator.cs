using System.Net;
using System.Net.Http.Headers;
using System.Reflection;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Serialization;

namespace GraphQlClientGenerator;

public class GraphQlGenerator
{
    private const string InputObjectInterfaceTypeName = "IGraphQlInputObject";

    internal const string AutoGeneratedLabel = "// <auto-generated> This file has been auto generated. </auto-generated>";

    public const string PreprocessorDirectiveDisableNewtonsoftJson = "GRAPHQL_GENERATOR_DISABLE_NEWTONSOFT_JSON";

    public const string RequiredNamespaces =
        $"""
        using System;
        using System.Collections;
        using System.Collections.Generic;
        using System.ComponentModel;
        using System.Globalization;
        using System.Linq;
        using System.Reflection;
        using System.Runtime.Serialization;
        using System.Text;
        using System.Text.RegularExpressions;
        #if !{PreprocessorDirectiveDisableNewtonsoftJson}
        using Newtonsoft.Json;
        using Newtonsoft.Json.Linq;
        #endif

        """;

    private delegate void WriteDataClassPropertyBodyDelegate(ScalarFieldTypeDescription netType, string backingFieldName);

    public static HttpClientHandler CreateDefaultHttpClientHandler() =>
        new() { AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate };

    private static HttpClient CreateHttpClient(HttpMessageHandler messageHandler = null) =>
        new(messageHandler ?? CreateDefaultHttpClientHandler())
        {
            DefaultRequestHeaders =
            {
                UserAgent = { ProductInfoHeaderValue.Parse($"GraphQlClientGenerator/{typeof(GraphQlGenerator).GetTypeInfo().Assembly.GetName().Version}") }
            }
        };

    private static readonly JsonSerializerSettings SerializerSettings =
        new()
        {
            ContractResolver = new CamelCasePropertyNamesContractResolver(),
            Converters = { new StringEnumConverter() }
        };

    private static readonly GraphQlField TypeNameField =
        new()
        {
            Name = NamingHelper.MetadataFieldTypeName,
            Type = new GraphQlFieldType
            {
                Kind = GraphQlTypeKind.Scalar,
                Name = "String"
            }
        };

    private readonly GraphQlGeneratorConfiguration _configuration;

    public GraphQlGenerator(GraphQlGeneratorConfiguration configuration = null) =>
        _configuration = configuration ?? new GraphQlGeneratorConfiguration();

    public static async Task<GraphQlSchema> RetrieveSchema(HttpMethod method, string url, IEnumerable<KeyValuePair<string, string>> headers = null, HttpMessageHandler messageHandler = null)
    {
        StringContent requestContent = null;
        if (method == HttpMethod.Get)
            url += $"?&query={IntrospectionQuery.Text}";
        else
            requestContent = new StringContent(JsonConvert.SerializeObject(new { query = IntrospectionQuery.Text }), Encoding.UTF8, "application/json");

        using var request = new HttpRequestMessage(method, url);
        request.Content = requestContent;

        if (headers is not null)
            foreach (var kvp in headers)
                request.Headers.TryAddWithoutValidation(kvp.Key, kvp.Value);

        using var httpClient = CreateHttpClient(messageHandler);
        using var response = await httpClient.SendAsync(request);

        var content =
            response.Content is null
                ? "(no content)"
                : await response.Content.ReadAsStringAsync();

        if (!response.IsSuccessStatusCode)
            throw new InvalidOperationException($"Status code: {(int)response.StatusCode} ({response.StatusCode}); content: {content}");

        return DeserializeGraphQlSchema(content);
    }

    public static GraphQlSchema DeserializeGraphQlSchema(string content)
    {
        try
        {
            var schema =
                JsonConvert.DeserializeObject<GraphQlResult>(content, SerializerSettings)?.Data?.Schema
                ?? JsonConvert.DeserializeObject<GraphQlData>(content, SerializerSettings)?.Schema;

            return schema ?? throw new ArgumentException("not a GraphQL schema", nameof(content));
        }
        catch (JsonReaderException exception)
        {
            throw new ArgumentException("not a GraphQL schema", nameof(content), exception);
        }
    }

    public string GenerateFullClientCSharpFile(GraphQlSchema schema, string @namespace, Action<string> logMessage = null)
    {
        var builder = new StringBuilder();
        using var writer = new StringWriter(builder);
        WriteFullClientCSharpFile(schema, @namespace, writer, logMessage);
        return builder.ToString();
    }

    public void WriteFullClientCSharpFile(GraphQlSchema schema, string @namespace, TextWriter writer, Action<string> logMessage = null)
    {
        if (String.IsNullOrWhiteSpace(@namespace))
            throw new ArgumentException("namespace required", nameof(@namespace));

        if (!CSharpHelper.IsValidNamespace(@namespace))
            throw new ArgumentException($"invalid namespace \"{@namespace}\"", nameof(@namespace));

        writer.WriteLine(AutoGeneratedLabel);
        writer.WriteLine();
        writer.WriteLine(RequiredNamespaces);
        writer.Write("namespace ");
        writer.Write(@namespace);

        if (_configuration.FileScopedNamespaces)
        {
            writer.WriteLine(";");
            writer.WriteLine();
            Generate(new SingleFileGenerationContext(schema, writer, indentationSizeSize: 0) { LogMessage = logMessage });
        }
        else
        {
            writer.WriteLine();
            writer.WriteLine("{");
            Generate(new SingleFileGenerationContext(schema, writer, indentationSizeSize: 4) { LogMessage = logMessage });
            writer.WriteLine("}");
        }

        writer.Flush();
    }

    public string Generate(GraphQlSchema schema)
    {
        var builder = new StringBuilder();
        using var writer = new StringWriter(builder);
        Generate(new SingleFileGenerationContext(schema, writer));
        return builder.ToString();
    }

    public void Generate(GenerationContext context)
    {
        context.Initialize(_configuration);
        context.BeforeGeneration();

        GenerateBaseClasses(context);

        GenerateGraphQlTypeNames(context);

        GenerateEnums(context);

        GenerateDirectives(context);

        GenerateQueryBuilders(context);

        GenerateInputObjects(context);

        GenerateDataClasses(context);

        context.AfterGeneration();
    }

    private void GenerateGraphQlTypeNames(GenerationContext context)
    {
        context.BeforeGraphQlTypeNameGeneration();

        var indentation = GetIndentation(context.IndentationSize);
        var writer = context.Writer;
        writer.Write(indentation);
        writer.WriteLine("public static class GraphQlTypes");
        writer.Write(indentation);
        writer.WriteLine("{");

        var graphQlTypes = context.Schema.Types.Where(t => !t.IsBuiltIn()).OrderBy(t => t.Kind).ThenBy(t => t.Name).ToArray();
        GraphQlType precedingInputObjectType = null;
        foreach (var inputObjectType in graphQlTypes)
        {
            if (precedingInputObjectType is not null && inputObjectType.Kind != precedingInputObjectType.Kind)
                writer.WriteLine();

            writer.Write(indentation);
            writer.Write("    public const string ");
            writer.Write(NamingHelper.ToPascalCase(inputObjectType.Name));
            writer.Write(" = \"");
            writer.Write(inputObjectType.Name);
            writer.WriteLine("\";");

            precedingInputObjectType = inputObjectType;
        }

        writer.WriteLine();
        writer.Write(indentation);
        writer.WriteLine("    public static readonly IReadOnlyDictionary<Type, string> ReverseMapping =");
        writer.Write(indentation);
        writer.WriteLine("        new Dictionary<Type, string>");
        writer.Write(indentation);
        writer.WriteLine("        {");

        var netTypeKeys = new HashSet<string>();
        string typeMappingSeparator = null;

        foreach (var type in graphQlTypes.Where(t => t.Kind is GraphQlTypeKind.Object or GraphQlTypeKind.InputObject))
        {
            if (type.Kind is GraphQlTypeKind.InputObject)
            {
                var netType = context.GetFullyQualifiedNetTypeName(context.GetCSharpClassName(type.Name), type.Kind);
                WriteMappingEntry(netType, type.Name);
            }
            else
            {
                foreach (var member in type.Kind is GraphQlTypeKind.Object ? (IEnumerable<IGraphQlMember>)type.Fields : type.InputFields)
                {
                    var fieldType = member.Type.UnwrapIfNonNull();
                    if (fieldType.Kind is GraphQlTypeKind.List)
                    {
                        var itemType = UnwrapListItemType(fieldType, false, false, out _, out _);
                        fieldType = itemType?.UnwrapIfNonNull();
                        if (fieldType is null)
                            continue;
                    }

                    if (fieldType.Kind != GraphQlTypeKind.Scalar)
                        continue;

                    var netType = context.ResolveScalarNetType(type, member.Name, member.Type, false).NetTypeName.TrimEnd('?');
                    if (netType.EndsWith("object") || netType.EndsWith("System.Object"))
                        continue;

                    WriteMappingEntry(netType, fieldType.Name);
                }
            }
        }

        writer.WriteLine();
        writer.Write(indentation);
        writer.WriteLine("        };");
        writer.WriteLine("}");

        context.AfterGraphQlTypeNameGeneration();

        return;

        void WriteMappingEntry(string netType, string graphQlTypeName)
        {
            if (!netTypeKeys.Add(netType))
                return;

            if (typeMappingSeparator is not null)
                writer.WriteLine(typeMappingSeparator);

            writer.Write(indentation);
            writer.Write("            { typeof(");
            writer.Write(netType);
            writer.Write("), \"");
            writer.Write(graphQlTypeName);
            writer.Write("\" }");

            typeMappingSeparator = ",";
        }
    }

    private void GenerateEnums(GenerationContext context)
    {
        var enumTypes = context.Schema.Types.Where(t => t.Kind == GraphQlTypeKind.Enum && !t.IsBuiltIn()).ToList();
        if (!enumTypes.Any())
            return;

        context.BeforeEnumsGeneration();

        enumTypes.ForEach(t => GenerateEnum(context, t));

        context.AfterEnumsGeneration();
    }

    private void GenerateQueryBuilders(GenerationContext context)
    {
        if (IsQueryBuilderGenerationDisabled(context.ObjectTypes))
            return;

        context.BeforeQueryBuildersGeneration();

        var complexTypes = context.Schema.GetComplexTypes().ToList();
        complexTypes.ForEach(t => GenerateQueryBuilder(context, t));

        context.AfterQueryBuildersGeneration();
    }

    private static void GenerateBaseClasses(GenerationContext context)
    {
        if (!context.ObjectTypes.HasFlag(GeneratedObjectType.BaseClasses))
            return;

        context.BeforeBaseClassGeneration();

        var indentation = GetIndentation(context.IndentationSize);
        const string resourceName = "GraphQlClientGenerator.BaseClasses.cs";
        var baseClassesStream = typeof(GraphQlGenerator).GetTypeInfo().Assembly.GetManifestResourceStream(resourceName);
        using var reader = new StreamReader(baseClassesStream ?? throw new InvalidOperationException($"\"{resourceName}\" resource not found"));
        do
        {
            var line = reader.ReadLine();
            if (line is null)
                break;

            context.Writer.Write(indentation);
            context.Writer.WriteLine(line.Replace("GRAPHQL_GENERATOR_DISABLE_NEWTONSOFT_JSON", PreprocessorDirectiveDisableNewtonsoftJson));
        } while (true);

        context.AfterBaseClassGeneration();
    }

    private static bool IsQueryBuilderGenerationDisabled(GeneratedObjectType objectTypes) => !objectTypes.HasFlag(GeneratedObjectType.QueryBuilders);

    private static bool IsDataClassGenerationDisabled(GeneratedObjectType objectTypes) => !objectTypes.HasFlag(GeneratedObjectType.DataClasses);

    private void GenerateInputObjects(GenerationContext context)
    {
        if (IsDataClassGenerationDisabled(context.ObjectTypes))
            return;

        var inputObjectTypes = context.Schema.GetInputObjectTypes().ToArray();
        if (!inputObjectTypes.Any())
            return;

        context.BeforeInputClassesGeneration();

        foreach (var inputObjectType in inputObjectTypes)
            GenerateFileMember(
                context,
                inputObjectType,
                [InputObjectInterfaceTypeName],
                c => GenerateInputDataClassBody(c, inputObjectType.InputFields, context));

        context.AfterInputClassesGeneration();
    }

    private void GenerateDataClasses(GenerationContext context)
    {
        if (IsDataClassGenerationDisabled(context.ObjectTypes))
            return;

        var complexTypes = context.Schema.GetComplexTypes().ToDictionary(t => t.Name);
        if (!complexTypes.Any())
            return;

        context.BeforeDataClassesGeneration();

        foreach (var complexType in complexTypes.Values)
        {
            if (complexType.Kind is GraphQlTypeKind.Union)
            {
                GenerateFileMember(context, complexType, [], c => GenerateDataClassBody(c, [], context, true));
                continue;
            }

            var isInterface = complexType.Kind is GraphQlTypeKind.Interface;
            var interfacesToImplement = new HashSet<string>(context.TypeUnionMembership[complexType.Name].Select(n => context.GetFullyQualifiedNetTypeName(n, GraphQlTypeKind.Interface)));
            var fieldsToGenerate = context.GetFieldsToGenerate(complexType).Select(f => new FieldGenerationInfo(f, complexType, false)).ToList();

            //var implementsUnion = interfacesToImplement.Any();
            if (complexType.Interfaces?.Count > 0)
            {
                var namedFields = fieldsToGenerate.ToDictionary(f => f.Field.Name);
                if (isInterface)
                    fieldsToGenerate.Clear();

                foreach (var @interface in complexType.Interfaces)
                {
                    var csharpInterfaceName = context.GetCSharpClassName(@interface.Name, false);
                    var interfaceName = context.GetFullyQualifiedNetTypeName(csharpInterfaceName, GraphQlTypeKind.Interface);
                    interfacesToImplement.Add(interfaceName);

                    var interfaceType = complexTypes[@interface.Name];
                    foreach (var interfaceField in interfaceType.Fields.Where(context.FilterIfDeprecated))
                    {
                        if (!IsFieldOwner(complexTypes, interfaceType, interfaceField))
                            continue;

                        var interfaceFieldNetType = context.GetDataPropertyType(interfaceType, interfaceField).NetTypeName;
                        if (namedFields.TryGetValue(interfaceField.Name, out var nameField))
                        {
                            if (context.GetDataPropertyType(nameField.OwnerType, nameField.Field).NetTypeName != interfaceFieldNetType)
                            {
                                fieldsToGenerate.Add(
                                    isInterface
                                        ? nameField with { RequiresNew = true }
                                        : new(interfaceField, interfaceType, false));
                            }
                        }
                        else
                        {
                            var missingField = new FieldGenerationInfo(interfaceField, complexType, false);
                            fieldsToGenerate.Add(missingField);
                            namedFields[interfaceField.Name] = missingField;
                        }
                    }
                }

                //fieldsToGenerate.Insert(0, TypeNameField);
            }
            /*else if (implementsUnion)
                fieldsToGenerate.Insert(0, TypeNameField);*/

            var hasInputReference = complexType.Kind is GraphQlTypeKind.InputObject && context.ReferencedObjectTypes.Contains(complexType.Name);
            if (hasInputReference)
                interfacesToImplement.Add("IGraphQlInputObject");

            if (isInterface || fieldsToGenerate.Any())
                GenerateFileMember(context, complexType, interfacesToImplement, c => GenerateBody(c, isInterface));

            continue;

            void GenerateBody(ObjectGenerationContext objectContext, bool isInterfaceMember)
            {
                if (hasInputReference)
                    GenerateInputDataClassBody(objectContext, fieldsToGenerate.Select(f => f.Field), context);
                else
                    GenerateDataClassBody(objectContext, fieldsToGenerate, context, isInterfaceMember);
            }
        }

        context.AfterDataClassesGeneration();
    }

    private static bool IsFieldOwner(Dictionary<string, GraphQlType> complexTypes, GraphQlType interfaceType, GraphQlField field)
    {
        if (interfaceType.Interfaces?.Count is null or 0)
            return true;

        foreach (var inheritedInterfaceReference in interfaceType.Interfaces)
        {
            var inheritedInterfaceType = complexTypes[inheritedInterfaceReference.Name];
            if (inheritedInterfaceType.Fields.Any(f => f.Name == field.Name && f.Type.Equals(field.Type)))
                return false;
        }

        return true;
    }

    private static string GetBackingFieldName(string graphQlFieldName, bool requiresRawName) =>
        requiresRawName
            ? $"_{graphQlFieldName}"
            : $"_{NamingHelper.LowerFirst(NamingHelper.ToPascalCase(graphQlFieldName))}";

    private void GenerateDataClassBody(ObjectGenerationContext objectContext, IReadOnlyCollection<FieldGenerationInfo> fieldsToGenerate, GenerationContext context, bool isInterfaceMember)
    {
        var type = objectContext.GraphQlType;
        var writer = context.Writer;
        var csharpNameLookup = fieldsToGenerate.Where(fi => fi.OwnerType == type).ToLookup(f => NamingHelper.ToPascalCase(f.Field.Name));
        var generateBackingFields = _configuration.PropertyGeneration == PropertyGenerationOption.BackingField && !isInterfaceMember;
        if (generateBackingFields)
        {
            var indentation = GetIndentation(context.IndentationSize);

            foreach (var fieldInfo in fieldsToGenerate)
            {
                if (fieldInfo.OwnerType != type)
                    continue;

                var propertyName = NamingHelper.ToPascalCase(fieldInfo.Field.Name);
                var backingFieldName = GetBackingFieldName(fieldInfo.Field.Name, csharpNameLookup[propertyName].Count() > 1);

                writer.Write(indentation);
                writer.Write("    private ");
                writer.Write(context.GetDataPropertyType(type, fieldInfo.Field).NetTypeName);
                writer.Write(' ');
                writer.Write(backingFieldName);
                writer.WriteLine(";");
            }

            writer.WriteLine();
        }

        foreach (var fieldInfo in fieldsToGenerate)
        {
            var propertyName = NamingHelper.ToPascalCase(fieldInfo.Field.Name);
            var requiresRawName = csharpNameLookup[propertyName].Count() > 1;
            if (requiresRawName)
                propertyName = fieldInfo.Field.Name;

            GenerateDataProperty(
                objectContext,
                new DataPropertyContext
                {
                    Member = fieldInfo.Field,
                    OwnerType = fieldInfo.OwnerType,
                    PropertyName = propertyName,
                    RequiresNew = fieldInfo.RequiresNew,
                    IsDeprecated = fieldInfo.Field.IsDeprecated,
                    DeprecationReason = fieldInfo.Field.DeprecationReason,
                    DecorateWithJsonPropertyAttribute = true,
                    RequiresRawName = requiresRawName
                },
                (_, backingFieldName) =>
                    writer.Write(
                        generateBackingFields
                            ? _configuration.PropertyAccessorBodyWriter(backingFieldName, context.GetDataPropertyType(type, fieldInfo.Field))
                            : " { get; set; }"),
                context);
        }
    }

    private void GenerateInputDataClassBody(ObjectGenerationContext objectContext, IEnumerable<IGraphQlMember> members, GenerationContext context)
    {
        var writer = context.Writer;
        var indentation = GetIndentation(context.IndentationSize);
        var propertyContexts = new Dictionary<string, DataPropertyContext>();

        foreach (var member in members)
        {
            var fieldName = GetBackingFieldName(member.Name, false);
            var originalFieldName = fieldName;
            var collidingNameExtendingIndex = 1;
            while (propertyContexts.ContainsKey(fieldName))
                fieldName = $"{originalFieldName}{++collidingNameExtendingIndex}";

            var propertyName = NamingHelper.ToPascalCase(member.Name);
            if (collidingNameExtendingIndex > 1)
                propertyName = $"{propertyName}{collidingNameExtendingIndex}";

            propertyContexts.Add(
                fieldName,
                new DataPropertyContext
                {
                    Member = member,
                    OwnerType = objectContext.GraphQlType,
                    PropertyName = propertyName,
                    RequiresNew = false,
                    IsDeprecated = false,
                    DeprecationReason = null,
                    DecorateWithJsonPropertyAttribute = true,
                    RequiresRawName = false
                });

            writer.Write(indentation);
            writer.Write("    private InputPropertyInfo ");
            writer.Write(fieldName);
            writer.WriteLine(";");
        }

        writer.WriteLine();

        var useCompatibleSyntax = _configuration.CSharpVersion is CSharpVersion.Compatible;

        foreach (var kvp in propertyContexts)
            GenerateDataProperty(
                objectContext,
                kvp.Value,
                (t, _) =>
                {
                    writer.WriteLine();
                    writer.Write(indentation);
                    writer.WriteLine("    {");
                    writer.Write(indentation);
                    writer.Write("        get");
                    writer.Write(useCompatibleSyntax ? " { return " : " => ");
                    writer.Write("(");
                    writer.Write(t.NetTypeName);
                    writer.Write(")");
                    writer.Write(kvp.Key);
                    writer.Write(".Value;");

                    if (useCompatibleSyntax)
                        writer.Write(" }");

                    writer.WriteLine();

                    writer.Write(indentation);
                    writer.Write("        set");
                    writer.Write(useCompatibleSyntax ? " { " : " => ");
                    writer.Write(kvp.Key);
                    writer.Write(" = new InputPropertyInfo { Name = \"");
                    writer.Write(kvp.Value.Member.Name);
                    writer.Write("\", Value = value");

                    if (!String.IsNullOrEmpty(t.FormatMask))
                    {
                        writer.Write(", FormatMask = \"");
                        writer.Write(t.FormatMask.Replace("\"", "\\\""));
                        writer.Write("\"");
                    }

                    writer.Write(" };");

                    if (useCompatibleSyntax)
                        writer.Write(" }");

                    writer.WriteLine();
                    writer.Write(indentation);
                    writer.WriteLine("    }");
                },
                context);

        writer.Write(indentation);
        writer.WriteLine("    IEnumerable<InputPropertyInfo> IGraphQlInputObject.GetPropertyValues()");
        writer.Write(indentation);
        writer.WriteLine("    {");

        foreach (var fieldName in propertyContexts.Keys)
        {
            writer.Write(indentation);
            writer.Write("        if (");
            writer.Write(fieldName);
            writer.Write(".Name != null) yield return ");
            writer.Write(fieldName);
            writer.WriteLine(";");
        }

        writer.Write(indentation);
        writer.WriteLine("    }");
    }

    private void GenerateFileMember(GenerationContext context, GraphQlType graphQlType, IReadOnlyCollection<string> interfaces, Action<ObjectGenerationContext> generateFileMemberBody)
    {
        var typeName = context.GetFullyQualifiedNetTypeName(context.GetCSharpClassName(graphQlType.Name), graphQlType.Kind);

        CSharpHelper.ValidateClassName(typeName);

        var objectGenerationContext = new ObjectGenerationContext { GraphQlType = graphQlType, CSharpTypeName = typeName };

        context.BeforeDataClassGeneration(objectGenerationContext);

        var writer = context.Writer;

        GenerateCodeComments(writer, graphQlType.Description, context.IndentationSize);

        var indentation = GetIndentation(context.IndentationSize);

        if (graphQlType.Kind != GraphQlTypeKind.Interface && interfaces.Any(i => i != InputObjectInterfaceTypeName))
        {
            writer.Write(indentation);
            writer.Write("[GraphQlObjectType(\"");
            writer.Write(graphQlType.Name);
            writer.WriteLine("\")]");
        }

        writer.Write(indentation);
        writer.Write(GetMemberAccessibility());
        writer.Write(' ');

        if (_configuration.GeneratePartialClasses)
            writer.Write("partial ");

        writer.Write(graphQlType.Kind is GraphQlTypeKind.Interface or GraphQlTypeKind.Union ? "interface" : "class");
        writer.Write(' ');
        writer.Write(typeName);

        if (interfaces.Count > 0)
        {
            writer.Write(" : ");
            var separator = String.Empty;
            foreach (var @interface in interfaces)
            {
                writer.Write(separator);
                writer.Write(@interface);
                separator = ", ";
            }
        }

        writer.WriteLine();
        writer.Write(indentation);
        writer.WriteLine('{');

        generateFileMemberBody(objectGenerationContext);

        writer.Write(indentation);
        writer.WriteLine('}');

        context.AfterDataClassGeneration(objectGenerationContext);
    }

    private string AddQuestionMarkIfNullableReferencesEnabled(string dataTypeIdentifier) =>
        AddQuestionMarkIfNullableReferencesEnabled(_configuration.CSharpVersion, dataTypeIdentifier);

    internal static string AddQuestionMarkIfNullableReferencesEnabled(CSharpVersion cSharpVersion, string dataTypeIdentifier) =>
        cSharpVersion is CSharpVersion.NewestWithNullableReferences ? $"{dataTypeIdentifier}?" : dataTypeIdentifier;

    private string GetMemberAccessibility() =>
        _configuration.MemberAccessibility is MemberAccessibility.Internal ? "internal" : "public";

    private void GenerateDataProperty(
        ObjectGenerationContext objectContext,
        DataPropertyContext propertyContext,
        WriteDataClassPropertyBodyDelegate writeBody,
        GenerationContext context)
    {
        var baseType = objectContext.GraphQlType;
        var member = propertyContext.Member;
        var propertyTypeDescription = context.GetDataPropertyType(propertyContext.OwnerType, member);
        var propertyTypeName = propertyTypeDescription.NetTypeName;

        var writer = context.Writer;

        GenerateCodeComments(writer, member.Description, context.IndentationSize + 4);

        var indentation = GetIndentation(context.IndentationSize);

        if (propertyContext.IsDeprecated)
            WriteObsoleteAttribute(writer, propertyContext.DeprecationReason, indentation);

        var decorateWithJsonPropertyAttribute = propertyContext.DecorateWithJsonPropertyAttribute;
        if (decorateWithJsonPropertyAttribute)
        {
            decorateWithJsonPropertyAttribute =
                _configuration.JsonPropertyGeneration is JsonPropertyGenerationOption.Always ||
                !String.Equals(
                    member.Name,
                    propertyContext.PropertyName.TrimStart('@'),
                    _configuration.JsonPropertyGeneration is JsonPropertyGenerationOption.CaseInsensitive ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);

            if (_configuration.JsonPropertyGeneration is JsonPropertyGenerationOption.Never or JsonPropertyGenerationOption.UseDefaultAlias)
                decorateWithJsonPropertyAttribute = false;
        }

        var isInterface = baseType.Kind is GraphQlTypeKind.Interface;
        var requiresExplicitInterfaceImplementation = baseType != propertyContext.OwnerType && !isInterface;
        var isInterfaceMember = isInterface || requiresExplicitInterfaceImplementation;
        var fieldType = member.Type.UnwrapIfNonNull();
        var isGraphQlInterfaceJsonConverterRequired =
            !requiresExplicitInterfaceImplementation &&
            (fieldType.Kind is GraphQlTypeKind.Interface or GraphQlTypeKind.Union ||
             fieldType.Kind is GraphQlTypeKind.List && UnwrapListItemType(fieldType, false, false, out _, out _).UnwrapIfNonNull().Kind is GraphQlTypeKind.Interface or GraphQlTypeKind.Union);

        var isBaseTypeInputObject = baseType.Kind == GraphQlTypeKind.InputObject;
        var isPreprocessorDirectiveDisableNewtonsoftJsonRequired = !isInterfaceMember && decorateWithJsonPropertyAttribute || isGraphQlInterfaceJsonConverterRequired || isBaseTypeInputObject;
        if (isPreprocessorDirectiveDisableNewtonsoftJsonRequired)
        {
            writer.Write(indentation);
            writer.Write("    #if !");
            writer.WriteLine(PreprocessorDirectiveDisableNewtonsoftJson);
        }

        if (!isInterfaceMember && decorateWithJsonPropertyAttribute)
        {
            writer.Write(indentation);
            writer.Write("    [JsonProperty(\"");
            writer.Write(member.Name);
            writer.WriteLine("\")]");
        }

        if (isGraphQlInterfaceJsonConverterRequired)
        {
            writer.Write(indentation);
            writer.WriteLine("    [JsonConverter(typeof(GraphQlInterfaceJsonConverter))]");
        }
        else if (isBaseTypeInputObject)
        {
            writer.Write(indentation);
            writer.Write("    [JsonConverter(typeof(QueryBuilderParameterConverter<");
            writer.Write(propertyTypeName);
            writer.WriteLine(">))]");
            propertyTypeName = AddQuestionMarkIfNullableReferencesEnabled($"QueryBuilderParameter<{propertyTypeName}>");
        }

        if (isPreprocessorDirectiveDisableNewtonsoftJsonRequired)
        {
            writer.Write(indentation);
            writer.WriteLine("    #endif");
        }

        writer.Write(indentation);
        writer.Write("    ");

        if (!isInterfaceMember)
            writer.Write("public ");

        if (propertyContext.RequiresNew)
            writer.Write("new ");

        writer.Write(propertyTypeName);
        writer.Write(' ');

        if (requiresExplicitInterfaceImplementation)
        {
            var csharpInterfaceName = context.GetFullyQualifiedNetTypeName(propertyContext.OwnerType.Name, propertyContext.OwnerType.Kind);
            writer.Write(csharpInterfaceName);
            writer.Write('.');
        }

        writer.Write(propertyContext.PropertyName);

        if (requiresExplicitInterfaceImplementation)
        {
            var useCompatibleSyntax = _configuration.CSharpVersion is CSharpVersion.Compatible;
            writer.Write(" { get");
            writer.Write(useCompatibleSyntax ? " { " : " => ");

            if (useCompatibleSyntax)
                writer.Write("return ");

            writer.Write(propertyContext.PropertyName);

            writer.Write(";");

            if (useCompatibleSyntax)
                writer.Write(" }");

            writer.Write(" set");
            writer.Write(useCompatibleSyntax ? " { " : " => ");
            WriteAccessorException("setter");
            writer.Write(';');

            if (useCompatibleSyntax)
                writer.Write(" }");

            writer.Write(" }");

            void WriteAccessorException(string accessor)
            {
                writer.Write("throw new NotSupportedException(\"Use \\\"");
                writer.Write(objectContext.CSharpTypeName);
                writer.Write('.');
                writer.Write(propertyContext.PropertyName);
                writer.Write("\\\" property ");
                writer.Write(accessor);
                writer.Write("\")");
            }
        }
        else
            writeBody(propertyTypeDescription with { NetTypeName = propertyTypeName }, GetBackingFieldName(member.Name, propertyContext.RequiresRawName));

        writer.WriteLine();
    }

    internal static InvalidOperationException ListItemTypeResolutionFailedException(string typeName, string fieldName) =>
        FieldTypeResolutionFailedException(typeName, fieldName, "list item type was not resolved; nested collections too deep");

    private static InvalidOperationException FieldTypeResolutionFailedException(string typeName, string fieldName, string reason) =>
        new($"field type resolution failed - type: {typeName}; field: {fieldName}{(reason is null ? null : $"; reason: {reason}")}");

    private void GenerateQueryBuilder(GenerationContext context, GraphQlType graphQlType)
    {
        var typeName = context.GetCSharpClassName(graphQlType.Name, false);
        var className = $"{_configuration.ClassPrefix}{typeName}QueryBuilder{_configuration.ClassSuffix}";
        var fields = graphQlType.Kind is GraphQlTypeKind.Union ? null : context.GetFieldsToGenerate(graphQlType);
        if (fields?.Count == 0)
            return;

        CSharpHelper.ValidateClassName(className);

        var objectGenerationContext =
            new ObjectGenerationContext
            {
                GraphQlType = graphQlType,
                CSharpTypeName = className
            };

        context.BeforeQueryBuilderGeneration(objectGenerationContext);

        var useCompatibleSyntax = _configuration.CSharpVersion is CSharpVersion.Compatible;
        var writer = context.Writer;
        var indentation = GetIndentation(context.IndentationSize);
        writer.Write(indentation);
        writer.Write(GetMemberAccessibility());
        writer.Write(' ');

        if (_configuration.GeneratePartialClasses)
            writer.Write("partial ");

        writer.Write("class ");
        writer.Write(className);
        writer.Write(" : GraphQlQueryBuilder<");
        writer.Write(className);
        writer.WriteLine(">");
        writer.Write(indentation);
        writer.WriteLine("{");
        writer.Write(indentation);
        writer.Write("    private static readonly GraphQlFieldMetadata[] AllFieldMetadata =");

        if (fields is null)
        {
            writer.Write(' ');
            writer.Write(useCompatibleSyntax ? "new GraphQlFieldMetadata[0]" : "Array.Empty<GraphQlFieldMetadata>()");
            writer.WriteLine(';');
            writer.WriteLine();
        }
        else
        {
            writer.WriteLine();

            var fieldMetadataIndentation = indentation;

            if (useCompatibleSyntax)
            {
                writer.Write(indentation);
                writer.WriteLine("        new []");
                fieldMetadataIndentation = $"{indentation}    ";
            }

            writer.Write(fieldMetadataIndentation);
            writer.WriteLine("    {");

            for (var i = 0; i < fields.Count; i++)
            {
                var comma = i == fields.Count - 1 ? null : ",";
                var field = fields[i];
                var fieldType = field.Type.UnwrapIfNonNull();
                var isList = fieldType.Kind == GraphQlTypeKind.List;
                var treatUnknownObjectAsComplex = context.IsUnknownObjectScalar(graphQlType, field.Name, fieldType) && !_configuration.TreatUnknownObjectAsScalar;
                var isComplex = isList || treatUnknownObjectAsComplex || fieldType.Kind.IsComplex();

                writer.Write(fieldMetadataIndentation);
                writer.Write("        new GraphQlFieldMetadata { Name = \"");
                writer.Write(field.Name);
                writer.Write('"');

                var csharpPropertyName = NamingHelper.ToPascalCase(field.Name);
                if (_configuration.JsonPropertyGeneration is JsonPropertyGenerationOption.UseDefaultAlias &&
                    !String.Equals(field.Name, csharpPropertyName, StringComparison.Ordinal))
                {
                    writer.Write(", DefaultAlias = \"");
                    writer.Write(csharpPropertyName);
                    writer.Write('"');
                }

                var requiresParameters = ResolveParameterDefinitions(context, graphQlType, field.Args).Any(a => !a.IsNullable);
                if (requiresParameters)
                    writer.Write(", RequiresParameters = true");

                if (isComplex)
                {
                    writer.Write(", IsComplex = true");

                    if (isList)
                    {
                        var itemType = UnwrapListItemType(fieldType, false, false, out _, out _)?.UnwrapIfNonNull();
                        fieldType = itemType ?? throw ListItemTypeResolutionFailedException(graphQlType.Name, field.Name);
                    }

                    if (fieldType.Kind != GraphQlTypeKind.Scalar && fieldType.Kind != GraphQlTypeKind.Enum && fieldType.Kind != GraphQlTypeKind.List)
                    {
                        var fieldTypeName = fieldType.Name ?? throw FieldTypeResolutionFailedException(graphQlType.Name, field.Name, null);
                        fieldTypeName = context.GetCSharpClassName(fieldTypeName, false);
                        writer.Write(", QueryBuilderType = typeof(");
                        writer.Write(_configuration.ClassPrefix);
                        writer.Write(fieldTypeName);
                        writer.Write("QueryBuilder");
                        writer.Write(_configuration.ClassSuffix);
                        writer.Write(")");
                    }
                }

                writer.Write(" }");
                writer.WriteLine(comma);
            }

            writer.Write(fieldMetadataIndentation);
            writer.WriteLine("    };");
            writer.WriteLine();
        }

        var directiveLocation = GetDirectiveLocation(context.Schema, graphQlType.Name);

        if (graphQlType.Kind is GraphQlTypeKind.Interface or GraphQlTypeKind.Union)
        {
            const string memberIndentation = "    ";
            writer.Write(indentation);
            writer.Write(memberIndentation);
            writer.Write("public ");
            writer.Write(className);
            writer.Write("()");

            if (useCompatibleSyntax)
            {
                writer.WriteLine();
                writer.Write(indentation);
                writer.Write(memberIndentation);
                writer.WriteLine('{');
                writer.Write(indentation);
                writer.Write(memberIndentation);
                writer.Write("    ");
                WriteWithTypeNameField();
                writer.Write(indentation);
                writer.Write(memberIndentation);
                writer.WriteLine('}');
            }
            else
            {
                writer.Write(" => ");
                WriteWithTypeNameField();
            }

            writer.WriteLine();

            void WriteWithTypeNameField()
            {
                writer.Write("WithTypeName(");

                if (_configuration.JsonPropertyGeneration is JsonPropertyGenerationOption.UseDefaultAlias)
                {
                    writer.Write('"');
                    writer.Write(NamingHelper.ToPascalCase(NamingHelper.MetadataFieldTypeName));
                    writer.Write('"');
                }

                writer.WriteLine(");");
            }
        }

        var hasQueryPrefix = directiveLocation != GraphQlDirectiveLocation.Field;

        WriteOverrideProperty("protected", "string", "TypeName", $"\"{graphQlType.Name}\"", indentation, writer);

        WriteOverrideProperty("public", "IReadOnlyList<GraphQlFieldMetadata>", "AllFields", "AllFieldMetadata", indentation, writer);

        var stringDataType = AddQuestionMarkIfNullableReferencesEnabled("string");

        if (hasQueryPrefix)
        {
            writer.Write(indentation);
            writer.Write("    public ");
            writer.Write(className);
            writer.Write("(");
            writer.Write(stringDataType);
            writer.Write(" operationName = null) : base(\"");
            writer.Write(directiveLocation.ToString().ToLowerInvariant());
            writer.WriteLine("\", operationName)");
            writer.Write(indentation);
            writer.WriteLine("    {");
            writer.Write(indentation);
            writer.WriteLine("    }");
            writer.WriteLine();

            writer.Write(indentation);
            writer.Write("    public ");
            writer.Write(className);
            writer.Write(" WithParameter<T>(GraphQlQueryParameter<T> parameter)");
            WriteQueryBuilderMethodBody(
                useCompatibleSyntax,
                indentation,
                writer,
                () => writer.WriteLine($"{ReturnPrefix(useCompatibleSyntax)}WithParameterInternal(parameter);"));

            writer.WriteLine();
        }

        var fragments = context.GetFragments(graphQlType);
        fields ??= [];
        var firstFragmentIndex = fields.Count;
        fields.AddRange(fragments);
        var csharpNameLookup = fields.ToLookup(f => NamingHelper.ToPascalCase(f.Name));

        for (var i = 0; i < fields.Count; i++)
        {
            var field = fields[i];
            var fieldType = UnwrapIfNotNullOrList(field.Type);
            var isFragment = i >= firstFragmentIndex;
            var argumentDefinitions = ResolveParameterDefinitions(context, graphQlType, field.Args);
            var argumentCollectionVariableName = "args";
            var counter = 0;
            while (argumentDefinitions.Any(a => a.NetParameterName == argumentCollectionVariableName))
                switch (argumentCollectionVariableName)
                {
                    case "args":
                        argumentCollectionVariableName = "inputArgs";
                        break;

                    default:
                        argumentCollectionVariableName = $"inputArgs{(counter is 0 ? null : counter)}";
                        counter++;
                        break;
                }

            var methodParameters =
                String.Join(
                    ", ",
                    argumentDefinitions
                        .OrderByDescending(d => d.Argument.Type.Kind == GraphQlTypeKind.NonNull)
                        .Select(d => d.NetParameterDefinitionClause));

            var requiresFullBody = useCompatibleSyntax || argumentDefinitions.Any();
            var returnPrefix = ReturnPrefix(requiresFullBody);
            var csharpPropertyName = NamingHelper.ToPascalCase(field.Name);
            var requiresRawName = csharpNameLookup[csharpPropertyName].Count() > 1;
            if (requiresRawName)
                csharpPropertyName = field.Name;

            if (field.IsDeprecated)
                WriteObsoleteAttribute(writer, field.DeprecationReason, indentation);

            if (fieldType.Kind is GraphQlTypeKind.Scalar or GraphQlTypeKind.Enum or GraphQlTypeKind.List)
            {
                writer.Write(indentation);
                writer.Write("    public ");
                writer.Write(className);
                writer.Write(" With");
                writer.Write(csharpPropertyName);
                writer.Write("(");
                writer.Write(methodParameters);

                if (!String.IsNullOrEmpty(methodParameters))
                    writer.Write(", ");

                WriteAliasParameter();

                var fieldDirectiveParameterNameList = WriteDirectiveParameterList(context, argumentDefinitions);

                writer.Write(")");

                WriteQueryBuilderMethodBody(
                    requiresFullBody,
                    indentation,
                    writer,
                    () =>
                    {
                        AppendArgumentDictionary(indentation, writer, argumentDefinitions, argumentCollectionVariableName);

                        writer.Write(returnPrefix);
                        writer.Write("WithScalarField(\"");
                        writer.Write(field.Name);
                        writer.Write("\", alias, ");
                        writer.Write(fieldDirectiveParameterNameList);

                        if (argumentDefinitions.Count > 0)
                        {
                            writer.Write(", ");
                            writer.Write(argumentCollectionVariableName);
                        }

                        writer.WriteLine(");");
                    });
            }
            else
            {
                if (String.IsNullOrEmpty(fieldType.Name))
                    throw FieldTypeResolutionFailedException(graphQlType.Name, field.Name, null);

                var fieldTypeName = context.GetCSharpClassName(fieldType.Name, false);

                var builderParameterName = NamingHelper.LowerFirst(fieldTypeName);
                writer.Write(indentation);
                writer.Write("    public ");
                writer.Write(className);
                writer.Write(" With");
                writer.Write(csharpPropertyName);

                if (isFragment)
                    writer.Write("Fragment");

                writer.Write('(');
                writer.Write(_configuration.ClassPrefix);
                writer.Write(fieldTypeName);
                writer.Write("QueryBuilder");
                writer.Write(_configuration.ClassSuffix);
                writer.Write(' ');
                writer.Write(builderParameterName);
                writer.Write("QueryBuilder");

                if (argumentDefinitions.Count > 0)
                {
                    writer.Write(", ");
                    writer.Write(methodParameters);
                }

                if (!isFragment)
                {
                    writer.Write(", ");
                    WriteAliasParameter();
                }

                var fieldDirectiveParameterNameList = WriteDirectiveParameterList(context, argumentDefinitions);

                writer.Write(")");

                WriteQueryBuilderMethodBody(
                    requiresFullBody,
                    indentation,
                    writer,
                    () =>
                    {
                        AppendArgumentDictionary(indentation, writer, argumentDefinitions, argumentCollectionVariableName);

                        writer.Write(returnPrefix);
                        writer.Write("With");

                        if (isFragment)
                            writer.Write("Fragment(");
                        else
                        {
                            writer.Write("ObjectField(\"");
                            writer.Write(field.Name);
                            writer.Write("\", alias, ");
                        }

                        writer.Write(builderParameterName);
                        writer.Write("QueryBuilder");

                        writer.Write(", ");
                        writer.Write(fieldDirectiveParameterNameList);

                        if (argumentDefinitions.Count > 0)
                        {
                            writer.Write(", ");
                            writer.Write(argumentCollectionVariableName);
                        }

                        writer.WriteLine(");");
                    });
            }

            if (!isFragment)
            {
                writer.WriteLine();

                writer.Write(indentation);
                writer.Write("    public ");
                writer.Write(className);
                writer.Write(" Except");
                writer.Write(csharpPropertyName);
                writer.Write("()");

                WriteQueryBuilderMethodBody(
                    useCompatibleSyntax,
                    indentation,
                    writer,
                    () => writer.WriteLine($"{ReturnPrefix(useCompatibleSyntax)}ExceptField(\"{field.Name}\");"));
            }

            if (i < fields.Count - 1)
                writer.WriteLine();

            continue;

            void WriteAliasParameter()
            {
                writer.Write(stringDataType);
                writer.Write(" alias = ");

                if (_configuration.JsonPropertyGeneration is JsonPropertyGenerationOption.UseDefaultAlias &&
                    !String.Equals(field.Name, csharpPropertyName, StringComparison.Ordinal))
                {
                    writer.Write('"');
                    writer.Write(csharpPropertyName);
                    writer.Write('"');
                }
                else
                    writer.Write("null");
            }
        }

        writer.Write(indentation);
        writer.WriteLine("}");

        context.AfterQueryBuilderGeneration(objectGenerationContext);

        return;

        string ReturnPrefix(bool requiresFullBody) => requiresFullBody ? $"{indentation}        return " : String.Empty;
    }

    private static GraphQlDirectiveLocation GetDirectiveLocation(GraphQlSchema schema, string graphQlTypeName)
    {
        if (graphQlTypeName == schema.QueryType?.Name)
            return GraphQlDirectiveLocation.Query;

        if (graphQlTypeName == schema.MutationType?.Name)
            return GraphQlDirectiveLocation.Mutation;

        if (graphQlTypeName == schema.SubscriptionType?.Name)
            return GraphQlDirectiveLocation.Subscription;

        return GraphQlDirectiveLocation.Field;
    }

    private static void WriteObsoleteAttribute(TextWriter writer, string deprecationReason, string indentation)
    {
        deprecationReason = String.IsNullOrWhiteSpace(deprecationReason) ? null : $"(@\"{deprecationReason.Replace("\"", "\"\"")}\")";
        writer.Write(indentation);
        writer.Write("    [Obsolete");
        writer.Write(deprecationReason);
        writer.WriteLine("]");
    }

    private IReadOnlyList<QueryBuilderParameterDefinition> ResolveParameterDefinitions(GenerationContext context, GraphQlType type, IEnumerable<GraphQlArgument> graphQlArguments)
    {
        if (graphQlArguments is null)
            return [];

        var parameterDefinitions = new List<QueryBuilderParameterDefinition>();
        var collidingNames = new Dictionary<string, int>();
        foreach (var argument in graphQlArguments.Where(a => IsCompatibleArgument(a.Type)))
        {
            var netParameterName = NamingHelper.EnsureCSharpQuoting(NamingHelper.LowerFirst(NamingHelper.ToPascalCase(argument.Name)));
            collidingNames[netParameterName] = collidingNames.TryGetValue(netParameterName, out var extendingIndex) ? extendingIndex + 1 : 1;

            if (extendingIndex > 0)
                netParameterName = $"{netParameterName}{++extendingIndex}";

            parameterDefinitions.Add(BuildMethodParameterDefinition(context, type, argument, netParameterName));
        }

        return parameterDefinitions;

        static bool IsCompatibleArgument(GraphQlFieldType argumentType)
        {
            argumentType = argumentType.UnwrapIfNonNull();
            return
                argumentType.Kind switch
                {
                    GraphQlTypeKind.Scalar => true,
                    GraphQlTypeKind.Enum => true,
                    GraphQlTypeKind.InputObject => true,
                    GraphQlTypeKind.List => IsCompatibleArgument(argumentType.OfType),
                    _ => false
                };
        }
    }

    internal static GraphQlFieldType UnwrapIfNotNullOrList(GraphQlFieldType type)
    {
        var fieldType = type.UnwrapIfNonNull();
        if (fieldType.Kind is GraphQlTypeKind.List)
            fieldType = UnwrapListItemType(fieldType, false, false, out _, out _);

        return fieldType.UnwrapIfNonNull();
    }

    internal static GraphQlFieldType UnwrapListItemType(GraphQlFieldType type, bool nullableReferencesEnabled, bool isCovarianceRequired, out string netCollectionOpenType, out int levels)
    {
        levels = 0;

        var nullableSymbols = new List<string> { String.Empty };

        while (true)
        {
            levels++;

            var unwrappedType = type.OfType?.UnwrapIfNonNull();
            if (unwrappedType is null)
            {
                netCollectionOpenType = null;
                return null;
            }

            if (unwrappedType.Kind != GraphQlTypeKind.List)
            {
                type = type.OfType;
                break;
            }

            nullableSymbols.Add(type.OfType.Kind == GraphQlTypeKind.NonNull ? String.Empty : nullableReferencesEnabled ? "?" : String.Empty);
            type = unwrappedType;
        }

        nullableSymbols.Reverse();

        netCollectionOpenType =
            levels == 1
                ? isCovarianceRequired ? "IEnumerable<{0}>" : "ICollection<{0}>"
                : String.Concat(Enumerable.Repeat(isCovarianceRequired ? "IEnumerable<" : "ICollection<", levels).Append("{0}").Concat(nullableSymbols.Select(s => $">{s}")));

        return type;
    }

    private string WriteDirectiveParameterList(GenerationContext context, IEnumerable<QueryBuilderParameterDefinition> argumentDefinitions)
    {
        var argumentNames = new HashSet<string>(argumentDefinitions.Select(ad => ad.NetParameterName));
        var directiveParameterNames = new List<string>();

        foreach (var directive in context.Directives.Where(d => d.Locations.Contains(GraphQlDirectiveLocation.Field)))
        {
            var csharpDirectiveName = NamingHelper.ToPascalCase(directive.Name);
            var directiveClassName = $"{csharpDirectiveName}Directive";
            var directiveParameterName = NamingHelper.LowerFirst(csharpDirectiveName);

            if (argumentNames.Contains(directiveParameterName))
            {
                directiveParameterName += "Directive";

                if (argumentNames.Contains(directiveParameterName))
                {
                    directiveParameterName += "Value";

                    var parameterCounter = 0;
                    var directiveParameterNameWithCounter = directiveParameterName;
                    while (argumentNames.Contains(directiveParameterNameWithCounter))
                        directiveParameterNameWithCounter = directiveParameterName + ++parameterCounter;

                    directiveParameterName = directiveParameterNameWithCounter;
                }
            }

            directiveParameterNames.Add(directiveParameterName);

            var writer = context.Writer;
            writer.Write(", ");
            writer.Write(AddQuestionMarkIfNullableReferencesEnabled(directiveClassName));
            writer.Write(' ');
            writer.Write(directiveParameterName);
            writer.Write(" = null");
        }

        return
            directiveParameterNames.Any()
                ? $"new {AddQuestionMarkIfNullableReferencesEnabled("GraphQlDirective")}[] {{ {String.Join(", ", directiveParameterNames)} }}"
                : "null";
    }

    private static void WriteQueryBuilderMethodBody(bool requiresFullBody, string indentation, TextWriter writer, Action writeBody)
    {
        if (requiresFullBody)
        {
            writer.WriteLine();
            writer.Write(indentation);
            writer.WriteLine("    {");
        }
        else
            writer.Write(" => ");

        writeBody();

        if (requiresFullBody)
        {
            writer.Write(indentation);
            writer.WriteLine("    }");
        }
    }

    private void WriteOverrideProperty(string accessibility, string propertyType, string propertyName, string propertyValue, string indentation, TextWriter writer)
    {
        writer.Write(indentation);
        writer.Write("    ");
        writer.Write(accessibility);
        writer.Write(" override ");
        writer.Write(propertyType);
        writer.Write(' ');
        writer.Write(propertyName);
        writer.Write(" { get");

        if (_configuration.CSharpVersion == CSharpVersion.Compatible)
        {
            writer.Write(" { return ");
            writer.Write(propertyValue);
            writer.WriteLine("; } } ");
        }
        else
        {
            writer.Write("; } = ");
            writer.Write(propertyValue);
            writer.WriteLine(";");
        }

        writer.WriteLine();
    }

    private QueryBuilderParameterDefinition BuildMethodParameterDefinition(GenerationContext context, GraphQlType baseType, GraphQlArgument argument, string netParameterName)
    {
        var argumentType = argument.Type;
        var isArgumentNotNull = argumentType.Kind is GraphQlTypeKind.NonNull;
        var isTypeNotNull = isArgumentNotNull;
        var unwrappedType = argumentType.UnwrapIfNonNull();
        var isCollection = unwrappedType.Kind is GraphQlTypeKind.List;
        if (isCollection)
        {
            isTypeNotNull = unwrappedType.OfType.Kind is GraphQlTypeKind.NonNull;
            argumentType = unwrappedType.OfType;
            unwrappedType = argumentType.UnwrapIfNonNull();
        }

        var argumentTypeDescription =
            unwrappedType.Kind is GraphQlTypeKind.Enum
                ? ScalarFieldTypeDescription.FromNetTypeName($"{context.GetFullyQualifiedNetTypeName(NamingHelper.ToPascalCase(unwrappedType.Name), unwrappedType.Kind)}{(isTypeNotNull ? "?" : null)}")
                : context.ResolveScalarNetType(baseType, argument.Name, argumentType, false);

        var argumentNetType = argumentTypeDescription.NetTypeName;

        var isInputObject = unwrappedType.Kind == GraphQlTypeKind.InputObject;
        if (isInputObject)
        {
            argumentNetType = context.GetCSharpClassName(unwrappedType.Name);
            argumentNetType = context.GetFullyQualifiedNetTypeName(argumentNetType, unwrappedType.Kind);

            if (!isTypeNotNull)
                argumentNetType = AddQuestionMarkIfNullableReferencesEnabled(argumentNetType);
        }

        argumentNetType = isCollection ? $"QueryBuilderParameter<IEnumerable<{argumentNetType}>>" : $"QueryBuilderParameter<{argumentNetType}>";

        if (!isArgumentNotNull)
            argumentNetType = AddQuestionMarkIfNullableReferencesEnabled(argumentNetType);

        var argumentDefinition = $"{argumentNetType} {netParameterName}";
        if (!isArgumentNotNull)
            argumentDefinition = $"{argumentDefinition} = null";

        return
            new QueryBuilderParameterDefinition
            {
                Argument = argument,
                IsNullable = !isArgumentNotNull,
                NetParameterName = netParameterName,
                NetParameterDefinitionClause = argumentDefinition,
                FormatMask = argumentTypeDescription.FormatMask
            };
    }

    private static void AppendArgumentDictionary(string indentation, TextWriter writer, IReadOnlyCollection<QueryBuilderParameterDefinition> argumentDefinitions, string argumentCollectionVariableName)
    {
        if (argumentDefinitions.Count == 0)
            return;

        writer.Write(indentation);
        writer.Write("        var ");
        writer.Write(argumentCollectionVariableName);
        writer.WriteLine(" = new List<QueryBuilderArgumentInfo>();");

        foreach (var argumentDefinition in argumentDefinitions)
        {
            writer.Write(indentation);

            if (argumentDefinition.Argument.Type.Kind == GraphQlTypeKind.NonNull)
            {
                writer.Write("        ");
                WriteAddKeyValuePair(writer, argumentDefinition, argumentCollectionVariableName);
            }
            else
            {
                writer.Write("        if (");
                writer.Write(argumentDefinition.NetParameterName);
                writer.WriteLine(" != null)");
                writer.Write(indentation);
                writer.Write("            ");
                WriteAddKeyValuePair(writer, argumentDefinition, argumentCollectionVariableName);
                writer.WriteLine();
            }
        }

        return;

        static void WriteAddKeyValuePair(TextWriter writer, QueryBuilderParameterDefinition argumentDefinition, string variableName)
        {
            var argument = argumentDefinition.Argument;
            writer.Write(variableName);
            writer.Write(".Add(new QueryBuilderArgumentInfo { ArgumentName = \"");
            writer.Write(argument.Name);
            writer.Write("\", ArgumentValue = ");
            writer.Write(argumentDefinition.NetParameterName);

            if (!String.IsNullOrEmpty(argumentDefinition.FormatMask))
            {
                writer.Write(", FormatMask = \"");
                writer.Write(argumentDefinition.FormatMask.Replace("\"", "\\\""));
                writer.Write("\"");
            }

            writer.WriteLine("} );");
        }
    }

    private void GenerateEnum(GenerationContext context, GraphQlType graphQlType)
    {
        var enumName = context.GetFullyQualifiedNetTypeName(NamingHelper.ToPascalCase(graphQlType.Name), graphQlType.Kind);

        var objectGenerationContext =
            new ObjectGenerationContext
            {
                GraphQlType = graphQlType,
                CSharpTypeName = enumName
            };

        context.BeforeEnumGeneration(objectGenerationContext);

        var writer = context.Writer;

        GenerateCodeComments(writer, graphQlType.Description, context.IndentationSize);
        var indentation = GetIndentation(context.IndentationSize);
        writer.Write(indentation);
        writer.Write("public enum ");
        writer.WriteLine(enumName);
        writer.Write(indentation);
        writer.WriteLine("{");

        var useCSharpNaming = _configuration.EnumValueNaming == EnumValueNamingOption.CSharp;
        var enumFieldsToGenerate = graphQlType.EnumValues.Where(context.FilterIfDeprecated).ToArray();
        var byIdentifierGroupedFieldsToGenerate =
            enumFieldsToGenerate
                .GroupBy(v => useCSharpNaming ? NamingHelper.ToCSharpEnumName(v.Name) : NamingHelper.EnsureCSharpQuoting(v.Name))
                .ToArray();

        WriteReSharperInconsistentNamingDirective(writer, "disable", indentation);

        var valueCounter = 0;
        foreach (var nameValues in byIdentifierGroupedFieldsToGenerate)
        {
            foreach (var enumValue in nameValues)
            {
                GenerateCodeComments(writer, enumValue.Description, context.IndentationSize + 4);

                if (enumValue.IsDeprecated)
                    WriteObsoleteAttribute(writer, enumValue.DeprecationReason, indentation);

                writer.Write(indentation);
                writer.Write("    ");

                var enumIdentifier = nameValues.Count() == 1 ? nameValues.Key : enumValue.Name;
                if (useCSharpNaming && enumIdentifier != enumValue.Name)
                {
                    writer.Write("[EnumMember(Value = \"");
                    writer.Write(enumValue.Name);
                    writer.Write("\")] ");
                }

                writer.Write(enumIdentifier);

                if (++valueCounter < enumFieldsToGenerate.Length)
                    writer.Write(",");

                writer.WriteLine();
            }
        }

        WriteReSharperInconsistentNamingDirective(writer, "restore", indentation);

        writer.Write(indentation);
        writer.WriteLine("}");

        context.AfterEnumGeneration(objectGenerationContext);
    }

    private void WriteReSharperInconsistentNamingDirective(TextWriter writer, string directiveValue, string indentation)
    {
        if (_configuration.EnumValueNaming is EnumValueNamingOption.CSharp)
            return;

        writer.Write(indentation);
        writer.Write("    // ReSharper ");
        writer.Write(directiveValue);
        writer.WriteLine(" InconsistentNaming");
    }

    private static readonly HashSet<GraphQlDirectiveLocation> SupportedDirectiveLocations =
    [
        GraphQlDirectiveLocation.Object,
        GraphQlDirectiveLocation.Field,
        GraphQlDirectiveLocation.Query,
        GraphQlDirectiveLocation.Mutation,
        GraphQlDirectiveLocation.Subscription
    ];

    private void GenerateDirectives(GenerationContext context)
    {
        if (IsQueryBuilderGenerationDisabled(context.ObjectTypes))
            return;

        var directives = context.Directives.Where(t => SupportedDirectiveLocations.Overlaps(t.Locations)).ToList();
        if (!directives.Any())
            return;

        context.BeforeDirectivesGeneration();

        directives.ForEach(d => GenerateDirective(context, d));

        context.AfterDirectivesGeneration();
    }

    private void GenerateDirective(GenerationContext context, GraphQlDirective directive)
    {
        var directiveName = $"{NamingHelper.ToPascalCase(directive.Name)}Directive";

        context.BeforeDirectiveGeneration(directiveName);

        var writer = context.Writer;

        GenerateCodeComments(writer, directive.Description, context.IndentationSize);

        var orderedArgumentDefinitions =
            ResolveParameterDefinitions(
                context,
                new GraphQlType { Name = directive.Name, Description = directive.Description, InputFields = directive.Args } /* TODO: make some common ancestor */,
                directive.Args.OrderByDescending(a => a.Type.Kind is GraphQlTypeKind.NonNull));

        var argumentList = String.Join(", ", orderedArgumentDefinitions.Select(d => d.NetParameterDefinitionClause));

        var indentation = GetIndentation(context.IndentationSize);
        writer.Write(indentation);
        writer.Write("public class ");
        writer.Write(directiveName);
        writer.WriteLine(" : GraphQlDirective");
        writer.Write(indentation);
        writer.WriteLine("{");
        writer.Write(indentation);
        writer.Write("    public ");
        writer.Write(directiveName);
        writer.Write("(");
        writer.Write(argumentList);
        writer.Write(") : base(\"");
        writer.Write(directive.Name);
        writer.WriteLine("\")");
        writer.Write(indentation);
        writer.WriteLine("    {");

        foreach (var definition in orderedArgumentDefinitions)
        {
            writer.Write(indentation);
            writer.Write("        AddArgument(\"");
            writer.Write(definition.Argument.Name);
            writer.Write("\", ");
            writer.Write(definition.NetParameterName);
            writer.WriteLine(");");
        }

        writer.Write(indentation);
        writer.WriteLine("    }");
        writer.Write(indentation);
        writer.WriteLine("}");

        context.AfterDirectiveGeneration(directiveName);
    }

    private void GenerateCodeComments(TextWriter writer, string description, int indentationSize)
    {
        if (String.IsNullOrWhiteSpace(description))
            return;

        var indentation = GetIndentation(indentationSize);

        if (_configuration.CodeDocumentationType.HasFlag(CodeDocumentationType.XmlSummary))
        {
            writer.Write(indentation);
            writer.WriteLine("/// <summary>");
            writer.Write(indentation);
            writer.Write("/// ");
            writer.WriteLine(String.Join($"{Environment.NewLine}{indentation}/// ", description.Split('\n').Select(l => l.Trim())));
            writer.Write(indentation);
            writer.WriteLine("/// </summary>");
        }

        if (_configuration.CodeDocumentationType.HasFlag(CodeDocumentationType.DescriptionAttribute))
        {
            writer.Write(indentation);
            writer.Write("[Description(@\"");
            writer.Write(description.Replace("\"", "\"\""));
            writer.WriteLine("\")]");
        }
    }

    public static string GetIndentation(int size) => new(' ', size);

    private record struct QueryBuilderParameterDefinition(
        GraphQlArgument Argument,
        bool IsNullable,
        string NetParameterName,
        string NetParameterDefinitionClause,
        string FormatMask);

    private record struct DataPropertyContext(
        IGraphQlMember Member,
        GraphQlType OwnerType,
        string PropertyName,
        bool RequiresNew,
        bool IsDeprecated,
        string DeprecationReason,
        bool DecorateWithJsonPropertyAttribute,
        bool RequiresRawName);

    private record struct FieldGenerationInfo(GraphQlField Field, GraphQlType OwnerType, bool RequiresNew);
}
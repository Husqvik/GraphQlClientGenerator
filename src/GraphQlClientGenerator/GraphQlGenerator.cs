using System.Net.Http.Headers;
using System.Reflection;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Serialization;

namespace GraphQlClientGenerator;

public class GraphQlGenerator
{
    internal const string AutoGeneratedLabel = "// <auto-generated> This file has been auto generated. </auto-generated>";

    public const string PreprocessorDirectiveDisableNewtonsoftJson = "GRAPHQL_GENERATOR_DISABLE_NEWTONSOFT_JSON";

    public const string RequiredNamespaces =
        $@"using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
#if !{PreprocessorDirectiveDisableNewtonsoftJson}
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
#endif
";

    private delegate void WriteDataClassPropertyBodyDelegate(ScalarFieldTypeDescription netType, string backingFieldName);

    private static HttpClient CreateHttpClient(HttpMessageHandler messageHandler = null) =>
        new(messageHandler ?? new HttpClientHandler())
        {
            DefaultRequestHeaders =
            {
                UserAgent = { ProductInfoHeaderValue.Parse($"GraphQlClientGenerator/{typeof(GraphQlGenerator).GetTypeInfo().Assembly.GetName().Version}") }
            }
        };

    private static readonly JsonSerializerSettings SerializerSettings =
        new()
        {
            ContractResolver = new CamelCasePropertyNamesContractResolver(),
            Converters = { new StringEnumConverter() }
        };

    private readonly GraphQlGeneratorConfiguration _configuration;

    public GraphQlGenerator(GraphQlGeneratorConfiguration configuration = null) =>
        _configuration = configuration ?? new GraphQlGeneratorConfiguration();

    public static async Task<GraphQlSchema> RetrieveSchema(HttpMethod method, string url, IEnumerable<KeyValuePair<string, string>> headers = null, HttpMessageHandler messageHandler = null)
    {
        StringContent requestContent = null;
        if (method == HttpMethod.Get)
            url += $"?&query={IntrospectionQuery.Text}";
        else
            requestContent = new StringContent(JsonConvert.SerializeObject(new { query = IntrospectionQuery.Text }), Encoding.UTF8, "application/json");

        using var request = new HttpRequestMessage(method, url) { Content = requestContent };

        if (headers is not null)
            foreach (var kvp in headers)
                request.Headers.TryAddWithoutValidation(kvp.Key, kvp.Value);

        using var httpClient = CreateHttpClient(messageHandler);
        using var response = await httpClient.SendAsync(request);

        var content =
            response.Content is null
                ? "(no content)"
                : await response.Content.ReadAsStringAsync();

        if (!response.IsSuccessStatusCode)
            throw new InvalidOperationException($"Status code: {(int)response.StatusCode} ({response.StatusCode}); content: {content}");

        return DeserializeGraphQlSchema(content);
    }

    public static GraphQlSchema DeserializeGraphQlSchema(string content)
    {
        try
        {
            var schema =
                JsonConvert.DeserializeObject<GraphQlResult>(content, SerializerSettings)?.Data?.Schema
                ?? JsonConvert.DeserializeObject<GraphQlData>(content, SerializerSettings)?.Schema;

            return schema ?? throw new ArgumentException("not a GraphQL schema", nameof(content));
        }
        catch (JsonReaderException exception)
        {
            throw new ArgumentException("not a GraphQL schema", nameof(content), exception);
        }
    }

    public string GenerateFullClientCSharpFile(GraphQlSchema schema, string @namespace)
    {
        var builder = new StringBuilder();
        using var writer = new StringWriter(builder);
        WriteFullClientCSharpFile(schema, @namespace, writer);
        return builder.ToString();
    }

    public void WriteFullClientCSharpFile(GraphQlSchema schema, string @namespace, TextWriter writer)
    {
        if (String.IsNullOrWhiteSpace(@namespace))
            throw new ArgumentException("namespace required", nameof(@namespace));

        if (!CSharpHelper.IsValidNamespace(@namespace))
            throw new ArgumentException($"invalid namespace \"{@namespace}\"", nameof(@namespace));

        writer.WriteLine(AutoGeneratedLabel);
        writer.WriteLine();
        writer.WriteLine(RequiredNamespaces);
        writer.Write("namespace ");
        writer.Write(@namespace);

        if (_configuration.FileScopedNamespaces)
        {
            writer.WriteLine(";");
            writer.WriteLine();
            Generate(new SingleFileGenerationContext(schema, writer, indentationSize: 0));
        }
        else
        {
            writer.WriteLine();
            writer.WriteLine("{");
            Generate(new SingleFileGenerationContext(schema, writer, indentationSize: 4));
            writer.WriteLine("}");
        }

        writer.Flush();
    }

    public string Generate(GraphQlSchema schema)
    {
        var builder = new StringBuilder();
        using var writer = new StringWriter(builder);
        Generate(new SingleFileGenerationContext(schema, writer));
        return builder.ToString();
    }

    public void Generate(GenerationContext context)
    {
        context.Initialize(_configuration);
        context.BeforeGeneration();

        GenerateBaseClasses(context);

        GenerateGraphQlTypeNames(context);

        GenerateEnums(context);

        GenerateDirectives(context);

        GenerateQueryBuilders(context);

        GenerateInputObjects(context);

        GenerateDataClasses(context);

        context.AfterGeneration();
    }

    private void GenerateGraphQlTypeNames(GenerationContext context)
    {
        context.BeforeGraphQlTypeNameGeneration();

        var indentation = GetIndentation(context.Indentation);
        var writer = context.Writer;
        writer.Write(indentation);
        writer.WriteLine("public static class GraphQlTypes");
        writer.Write(indentation);
        writer.WriteLine("{");

        var graphQlTypes = context.Schema.Types.Where(t => !t.IsBuiltIn()).OrderBy(t => t.Kind).ThenBy(t => t.Name).ToArray();
        GraphQlType precedingInputObjectType = null;
        foreach (var inputObjectType in graphQlTypes)
        {
            if (precedingInputObjectType is not null && inputObjectType.Kind != precedingInputObjectType.Kind)
                writer.WriteLine();

            writer.Write(indentation);
            writer.Write("    public const string ");
            writer.Write(NamingHelper.ToPascalCase(inputObjectType.Name));
            writer.Write(" = \"");
            writer.Write(inputObjectType.Name);
            writer.WriteLine("\";");

            precedingInputObjectType = inputObjectType;
        }

        writer.WriteLine();
        writer.Write(indentation);
        writer.WriteLine("    public static readonly IReadOnlyDictionary<Type, string> ReverseMapping =");
        writer.Write(indentation);
        writer.WriteLine("        new Dictionary<Type, string>");
        writer.Write(indentation);
        writer.WriteLine("        {");

        var netTypeKeys = new HashSet<string>();
        string typeMappingSeparator = null;

        void WriteMappingEntry(string netType, string graphQlTypeName)
        {
            if (!netTypeKeys.Add(netType))
                return;

            if (typeMappingSeparator is not null)
                writer.WriteLine(typeMappingSeparator);

            writer.Write(indentation);
            writer.Write("            { typeof(");
            writer.Write(netType);
            writer.Write("), \"");
            writer.Write(graphQlTypeName);
            writer.Write("\" }");

            typeMappingSeparator = ",";
        }

        foreach (var type in graphQlTypes.Where(t => t.Kind is GraphQlTypeKind.Object or GraphQlTypeKind.InputObject or GraphQlTypeKind.Enum))
        {
            if (type.Kind is GraphQlTypeKind.InputObject or GraphQlTypeKind.Enum)
            {
                var netType = $"{_configuration.ClassPrefix}{context.GetCSharpClassName(type.Name)}{_configuration.ClassSuffix}";
                WriteMappingEntry(netType, type.Name);
            }
            else
            {
                foreach (var member in type.Kind == GraphQlTypeKind.Object ? (IEnumerable<IGraphQlMember>)type.Fields : type.InputFields)
                {
                    var fieldType = member.Type.UnwrapIfNonNull();
                    if (fieldType.Kind == GraphQlTypeKind.List)
                    {
                        var itemType = UnwrapListItemType(fieldType, false, out _);
                        fieldType = itemType?.UnwrapIfNonNull();
                        if (fieldType is null)
                            continue;
                    }

                    if (fieldType.Kind != GraphQlTypeKind.Scalar)
                        continue;

                    var netType = context.ResolveScalarNetType(type, member.Name, member.Type).NetTypeName.TrimEnd('?');
                    if (netType.EndsWith("object") || netType.EndsWith("System.Object"))
                        continue;

                    WriteMappingEntry(netType, fieldType.Name);
                }
            }
        }

        writer.WriteLine();
        writer.Write(indentation);
        writer.WriteLine("        };");
        writer.WriteLine("}");

        context.AfterGraphQlTypeNameGeneration();
    }

    private void GenerateEnums(GenerationContext context)
    {
        var enumTypes = context.Schema.Types.Where(t => t.Kind == GraphQlTypeKind.Enum && !t.IsBuiltIn()).ToList();
        if (!enumTypes.Any())
            return;

        context.BeforeEnumsGeneration();

        enumTypes.ForEach(t => GenerateEnum(context, t));

        context.AfterEnumsGeneration();
    }

    private void GenerateQueryBuilders(GenerationContext context)
    {
        if (IsQueryBuilderGenerationDisabled(context.ObjectTypes))
            return;

        context.BeforeQueryBuildersGeneration();

        var complexTypes = context.Schema.GetComplexTypes().ToList();
        complexTypes.ForEach(t => GenerateQueryBuilder(context, t));

        context.AfterQueryBuildersGeneration();
    }

    private static void GenerateBaseClasses(GenerationContext context)
    {
        if (!context.ObjectTypes.HasFlag(GeneratedObjectType.BaseClasses))
            return;

        context.BeforeBaseClassGeneration();

        var indentation = GetIndentation(context.Indentation);

        using var reader = new StreamReader(typeof(GraphQlGenerator).GetTypeInfo().Assembly.GetManifestResourceStream("GraphQlClientGenerator.BaseClasses.cs"));
        do
        {
            var line = reader.ReadLine();
            if (line is null)
                break;

            context.Writer.Write(indentation);
            context.Writer.WriteLine(line.Replace("GRAPHQL_GENERATOR_DISABLE_NEWTONSOFT_JSON", PreprocessorDirectiveDisableNewtonsoftJson));
        } while (true);

        context.AfterBaseClassGeneration();
    }

    private static bool IsQueryBuilderGenerationDisabled(GeneratedObjectType objectTypes) => !objectTypes.HasFlag(GeneratedObjectType.QueryBuilders);

    private static bool IsDataClassGenerationDisabled(GeneratedObjectType objectTypes) => !objectTypes.HasFlag(GeneratedObjectType.DataClasses);

    private void GenerateInputObjects(GenerationContext context)
    {
        if (IsDataClassGenerationDisabled(context.ObjectTypes))
            return;

        var inputObjectTypes = context.Schema.GetInputObjectTypes().ToArray();
        if (!inputObjectTypes.Any())
            return;

        context.BeforeInputClassesGeneration();

        foreach (var inputObjectType in inputObjectTypes)
        {
            GenerateFileMember(
                context,
                context.GetCSharpClassName(inputObjectType.Name),
                inputObjectType,
                "IGraphQlInputObject",
                () => GenerateInputDataClassBody(inputObjectType, inputObjectType.InputFields, context));
        }

        context.AfterInputClassesGeneration();
    }

    private void GenerateDataClasses(GenerationContext context)
    {
        if (IsDataClassGenerationDisabled(context.ObjectTypes))
            return;

        var complexTypes = context.Schema.GetComplexTypes().ToDictionary(t => t.Name);
        if (!complexTypes.Any())
            return;

        context.BeforeDataClassesGeneration();

        foreach (var complexType in complexTypes.Values)
        {
            var hasInputReference = context.ReferencedObjectTypes.Contains(complexType.Name);
            var fieldsToGenerate = context.GetFieldsToGenerate(complexType);
            var isInterface = complexType.Kind == GraphQlTypeKind.Interface;
            var csharpTypeName = context.GetCSharpClassName(complexType.Name);

            var interfacesToImplement = new List<string>();
            if (isInterface)
            {
                interfacesToImplement.Add(GenerateFileMember(context, csharpTypeName, complexType, null, () => GenerateBody(true)));
            }
            else if (complexType.Interfaces?.Count > 0)
            {
                var fieldNames = new HashSet<string>(fieldsToGenerate.Select(f => f.Name));

                foreach (var @interface in complexType.Interfaces)
                {
                    var csharpInterfaceName = context.GetCSharpClassName(@interface.Name, false);
                    var interfaceName = $"I{_configuration.ClassPrefix}{csharpInterfaceName}{_configuration.ClassSuffix}";
                    interfacesToImplement.Add(interfaceName);

                    foreach (var interfaceField in complexTypes[@interface.Name].Fields.Where(context.FilterDeprecatedFields))
                        if (fieldNames.Add(interfaceField.Name))
                            fieldsToGenerate.Add(interfaceField);
                }
            }

            if (hasInputReference)
                interfacesToImplement.Add("IGraphQlInputObject");

            if (!isInterface)
                GenerateFileMember(context, csharpTypeName, complexType, String.Join(", ", interfacesToImplement), () => GenerateBody(false));

            continue;

            void GenerateBody(bool isInterfaceMember)
            {
                var writer = context.Writer;
                if (hasInputReference)
                    GenerateInputDataClassBody(complexType, fieldsToGenerate, context);
                else if (fieldsToGenerate is not null)
                {
                    var csharpNameLookup = fieldsToGenerate.ToLookup(f => NamingHelper.ToPascalCase(f.Name));
                    var generateBackingFields = _configuration.PropertyGeneration == PropertyGenerationOption.BackingField && !isInterfaceMember;
                    if (generateBackingFields)
                    {
                        var indentation = GetIndentation(context.Indentation);

                        foreach (var field in fieldsToGenerate)
                        {
                            var propertyName = NamingHelper.ToPascalCase(field.Name);
                            var backingFieldName = GetBackingFieldName(field.Name, csharpNameLookup[propertyName].Count() > 1);

                            writer.Write(indentation);
                            writer.Write("    private ");
                            writer.Write(context.GetDataPropertyType(complexType, field).NetTypeName);
                            writer.Write(" ");
                            writer.Write(backingFieldName);
                            writer.WriteLine(";");
                        }

                        writer.WriteLine();
                    }

                    foreach (var field in fieldsToGenerate)
                    {
                        var propertyName = NamingHelper.ToPascalCase(field.Name);
                        var requiresRawName = csharpNameLookup[propertyName].Count() > 1;
                        if (requiresRawName)
                            propertyName = field.Name;

                        GenerateDataProperty(
                            complexType,
                            new DataPropertyContext
                            {
                                Member = field,
                                PropertyName = propertyName,
                                IsDeprecated = field.IsDeprecated,
                                DeprecationReason = field.DeprecationReason,
                                DecorateWithJsonPropertyAttribute = true,
                                RequiresRawName = requiresRawName
                            },
                            (_, backingFieldName) =>
                                writer.Write(generateBackingFields
                                    ? _configuration.PropertyAccessorBodyWriter(backingFieldName, context.GetDataPropertyType(complexType, field))
                                    : " { get; set; }"),
                            context);
                    }
                }
            }
        }

        context.AfterDataClassesGeneration();
    }

    private static string GetBackingFieldName(string graphQlFieldName, bool requiresRawName) =>
        requiresRawName
            ? $"_{graphQlFieldName}"
            : $"_{NamingHelper.LowerFirst(NamingHelper.ToPascalCase(graphQlFieldName))}";

    private void GenerateInputDataClassBody(GraphQlType type, IEnumerable<IGraphQlMember> members, GenerationContext context)
    {
        var writer = context.Writer;
        var indentation = GetIndentation(context.Indentation);
        var propertyContexts = new Dictionary<string, DataPropertyContext>();

        foreach (var member in members)
        {
            var fieldName = GetBackingFieldName(member.Name, false);
            var originalFieldName = fieldName;
            var collidingNameExtendingIndex = 1;
            while (propertyContexts.ContainsKey(fieldName))
                fieldName = $"{originalFieldName}{++collidingNameExtendingIndex}";

            var propertyName = NamingHelper.ToPascalCase(member.Name);
            if (collidingNameExtendingIndex > 1)
                propertyName = $"{propertyName}{collidingNameExtendingIndex}";

            propertyContexts.Add(
                fieldName,
                new DataPropertyContext
                {
                    Member = member,
                    PropertyName = propertyName,
                    IsDeprecated = false,
                    DeprecationReason = null,
                    DecorateWithJsonPropertyAttribute = true,
                    RequiresRawName = false
                });

            writer.Write(indentation);
            writer.Write("    private InputPropertyInfo ");
            writer.Write(fieldName);
            writer.WriteLine(";");
        }

        writer.WriteLine();

        var useCompatibleSyntax = _configuration.CSharpVersion == CSharpVersion.Compatible;

        foreach (var kvp in propertyContexts)
            GenerateDataProperty(
                type,
                kvp.Value,
                (t, _) =>
                {
                    writer.WriteLine();
                    writer.Write(indentation);
                    writer.WriteLine("    {");
                    writer.Write(indentation);
                    writer.Write("        get");
                    writer.Write(useCompatibleSyntax ? " { return " : " => ");
                    writer.Write("(");
                    writer.Write(t.NetTypeName);
                    writer.Write(")");
                    writer.Write(kvp.Key);
                    writer.Write(".Value;");

                    if (useCompatibleSyntax)
                        writer.Write(" }");

                    writer.WriteLine();

                    writer.Write(indentation);
                    writer.Write("        set");
                    writer.Write(useCompatibleSyntax ? " { " : " => ");
                    writer.Write(kvp.Key);
                    writer.Write(" = new InputPropertyInfo { Name = \"");
                    writer.Write(kvp.Value.Member.Name);
                    writer.Write("\", Value = value");

                    if (!String.IsNullOrEmpty(t.FormatMask))
                    {
                        writer.Write(", FormatMask = \"");
                        writer.Write(t.FormatMask.Replace("\"", "\\\""));
                        writer.Write("\"");
                    }

                    writer.Write(" };");

                    if (useCompatibleSyntax)
                        writer.Write(" }");

                    writer.WriteLine();
                    writer.Write(indentation);
                    writer.WriteLine("    }");
                },
                context);

        writer.Write(indentation);
        writer.WriteLine("    IEnumerable<InputPropertyInfo> IGraphQlInputObject.GetPropertyValues()");
        writer.Write(indentation);
        writer.WriteLine("    {");

        foreach (var fieldName in propertyContexts.Keys)
        {
            writer.Write(indentation);
            writer.Write("        if (");
            writer.Write(fieldName);
            writer.Write(".Name != null) yield return ");
            writer.Write(fieldName);
            writer.WriteLine(";");
        }

        writer.Write(indentation);
        writer.WriteLine("    }");
    }

    private string GenerateFileMember(GenerationContext context, string typeName, GraphQlType graphQlType, string baseTypeName, Action generateFileMemberBody)
    {
        typeName = $"{_configuration.ClassPrefix}{typeName}{_configuration.ClassSuffix}";

        if (graphQlType.Kind == GraphQlTypeKind.Interface)
            typeName = $"I{typeName}";

        CSharpHelper.ValidateClassName(typeName);

        context.BeforeDataClassGeneration(
            new ObjectGenerationContext
            {
                GraphQlType = graphQlType,
                CSharpTypeName = typeName
            });

        var writer = context.Writer;

        GenerateCodeComments(writer, graphQlType.Description, context.Indentation);

        var indentation = GetIndentation(context.Indentation);

        if (graphQlType.Interfaces?.Count > 0)
        {
            writer.Write(indentation);
            writer.Write("[GraphQlObjectType(\"");
            writer.Write(graphQlType.Name);
            writer.WriteLine("\")]");
        }

        writer.Write(indentation);
        writer.Write(GetMemberAccessibility());
        writer.Write(" ");

        if (_configuration.GeneratePartialClasses)
            writer.Write("partial ");

        writer.Write(graphQlType.Kind == GraphQlTypeKind.Interface ? "interface" : "class");
        writer.Write(" ");
        writer.Write(typeName);

        if (!String.IsNullOrEmpty(baseTypeName))
        {
            writer.Write(" : ");
            writer.Write(baseTypeName);
        }

        writer.WriteLine();
        writer.Write(indentation);
        writer.WriteLine("{");

        generateFileMemberBody();

        writer.Write(indentation);
        writer.WriteLine("}");

        context.AfterDataClassGeneration(
            new ObjectGenerationContext
            {
                GraphQlType = graphQlType,
                CSharpTypeName = typeName
            });

        return typeName;
    }

    private string AddQuestionMarkIfNullableReferencesEnabled(string dataTypeIdentifier) =>
        AddQuestionMarkIfNullableReferencesEnabled(_configuration, dataTypeIdentifier);

    internal static string AddQuestionMarkIfNullableReferencesEnabled(GraphQlGeneratorConfiguration configuration, string dataTypeIdentifier) =>
        configuration.CSharpVersion == CSharpVersion.NewestWithNullableReferences ? $"{dataTypeIdentifier}?" : dataTypeIdentifier;

    private string GetMemberAccessibility() =>
        _configuration.MemberAccessibility == MemberAccessibility.Internal ? "internal" : "public";

    private void GenerateDataProperty(
        GraphQlType baseType,
        DataPropertyContext propertyContext,
        WriteDataClassPropertyBodyDelegate writeBody,
        GenerationContext context)
    {
        var member = propertyContext.Member;
        var propertyTypeDescription = context.GetDataPropertyType(baseType, member);
        var propertyTypeName = propertyTypeDescription.NetTypeName;

        var writer = context.Writer;

        GenerateCodeComments(writer, member.Description, context.Indentation + 4);

        var indentation = GetIndentation(context.Indentation);

        if (propertyContext.IsDeprecated)
            WriteObsoleteAttribute(writer, propertyContext.DeprecationReason, indentation);

        var decorateWithJsonPropertyAttribute = propertyContext.DecorateWithJsonPropertyAttribute;
        if (decorateWithJsonPropertyAttribute)
        {
            decorateWithJsonPropertyAttribute =
                _configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.Always ||
                !String.Equals(
                    member.Name,
                    propertyContext.PropertyName.TrimStart('@'),
                    _configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.CaseInsensitive ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);

            if (_configuration.JsonPropertyGeneration is JsonPropertyGenerationOption.Never or JsonPropertyGenerationOption.UseDefaultAlias)
                decorateWithJsonPropertyAttribute = false;
        }

        var isInterfaceMember = baseType.Kind == GraphQlTypeKind.Interface;
        var fieldType = member.Type.UnwrapIfNonNull();
        var isGraphQlInterfaceJsonConverterRequired = fieldType.Kind == GraphQlTypeKind.Interface ||
                                                      fieldType.Kind == GraphQlTypeKind.List && UnwrapListItemType(fieldType, false, out _).UnwrapIfNonNull().Kind == GraphQlTypeKind.Interface;
        var isBaseTypeInputObject = baseType.Kind == GraphQlTypeKind.InputObject;
        var isPreprocessorDirectiveDisableNewtonsoftJsonRequired = !isInterfaceMember && decorateWithJsonPropertyAttribute || isGraphQlInterfaceJsonConverterRequired || isBaseTypeInputObject;
        if (isPreprocessorDirectiveDisableNewtonsoftJsonRequired)
        {
            writer.Write(indentation);
            writer.Write("    #if !");
            writer.WriteLine(PreprocessorDirectiveDisableNewtonsoftJson);
        }

        if (!isInterfaceMember && decorateWithJsonPropertyAttribute)
        {
            writer.Write(indentation);
            writer.WriteLine($"    [JsonProperty(\"{member.Name}\")]");
        }

        if (isGraphQlInterfaceJsonConverterRequired)
        {
            writer.Write(indentation);
            writer.WriteLine("    [JsonConverter(typeof(GraphQlInterfaceJsonConverter))]");
        }
        else if (isBaseTypeInputObject)
        {
            writer.Write(indentation);
            writer.WriteLine($"    [JsonConverter(typeof(QueryBuilderParameterConverter<{propertyTypeName}>))]");
            propertyTypeName = AddQuestionMarkIfNullableReferencesEnabled($"QueryBuilderParameter<{propertyTypeName}>");
        }

        if (isPreprocessorDirectiveDisableNewtonsoftJsonRequired)
        {
            writer.Write(indentation);
            writer.WriteLine("    #endif");
        }

        writer.Write(indentation);
        writer.Write("    ");

        if (!isInterfaceMember)
            writer.Write("public ");

        writer.Write(propertyTypeName);
        writer.Write(" ");
        writer.Write(propertyContext.PropertyName);

        writeBody(propertyTypeDescription with { NetTypeName = propertyTypeName }, GetBackingFieldName(member.Name, propertyContext.RequiresRawName));

        writer.WriteLine();
    }

    internal static InvalidOperationException ListItemTypeResolutionFailedException(string typeName, string fieldName) =>
        FieldTypeResolutionFailedException(typeName, fieldName, "list item type was not resolved; nested collections too deep");

    private static InvalidOperationException FieldTypeResolutionFailedException(string typeName, string fieldName, string reason) =>
        new($"field type resolution failed - type: {typeName}; field: {fieldName}{(reason is null ? null : $"; reason: {reason}")}");

    private void GenerateQueryBuilder(GenerationContext context, GraphQlType graphQlType)
    {
        var schema = context.Schema;
        var typeName = context.GetCSharpClassName(graphQlType.Name, false);
        var className = $"{_configuration.ClassPrefix}{typeName}QueryBuilder{_configuration.ClassSuffix}";

        var fields = graphQlType.Kind == GraphQlTypeKind.Union ? null : context.GetFieldsToGenerate(graphQlType);
        if (fields?.Count == 0)
            return;

        CSharpHelper.ValidateClassName(className);

        context.BeforeQueryBuilderGeneration(
            new ObjectGenerationContext
            {
                GraphQlType = graphQlType,
                CSharpTypeName = className
            });

        var writer = context.Writer;
        var indentation = GetIndentation(context.Indentation);
        writer.Write(indentation);
        writer.Write(GetMemberAccessibility());
        writer.Write(" ");

        if (_configuration.GeneratePartialClasses)
            writer.Write("partial ");

        writer.Write("class ");
        writer.Write(className);
        writer.Write(" : GraphQlQueryBuilder<");
        writer.Write(className);
        writer.WriteLine(">");
        writer.Write(indentation);
        writer.WriteLine("{");
        writer.Write(indentation);
        writer.Write("    private static readonly GraphQlFieldMetadata[] AllFieldMetadata =");

        if (fields is null)
        {
            writer.WriteLine(" new GraphQlFieldMetadata[0];");
            writer.WriteLine();
        }
        else
        {
            writer.WriteLine();

            var fieldMetadataIndentation = indentation;

            if (_configuration.CSharpVersion == CSharpVersion.Compatible)
            {
                writer.Write(indentation);
                writer.WriteLine("        new []");
                fieldMetadataIndentation = $"{indentation}    ";
            }

            writer.Write(fieldMetadataIndentation);
            writer.WriteLine("    {");

            for (var i = 0; i < fields.Count; i++)
            {
                var comma = i == fields.Count - 1 ? null : ",";
                var field = fields[i];
                var fieldType = field.Type.UnwrapIfNonNull();
                var isList = fieldType.Kind == GraphQlTypeKind.List;
                var treatUnknownObjectAsComplex = context.IsUnknownObjectScalar(graphQlType, field.Name, fieldType) && !_configuration.TreatUnknownObjectAsScalar;
                var isComplex = isList || treatUnknownObjectAsComplex || fieldType.Kind.IsComplex();

                writer.Write(fieldMetadataIndentation);
                writer.Write("        new GraphQlFieldMetadata { Name = \"");
                writer.Write(field.Name);
                writer.Write('"');

                var csharpPropertyName = NamingHelper.ToPascalCase(field.Name);
                if (_configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.UseDefaultAlias && !String.Equals(field.Name, csharpPropertyName, StringComparison.OrdinalIgnoreCase))
                {
                    writer.Write(", DefaultAlias = \"");
                    writer.Write(NamingHelper.LowerFirst(csharpPropertyName));
                    writer.Write('"');
                }

                var requiresParameters = ResolveParameterDefinitions(context, graphQlType, field.Args).Any(a => !a.IsNullable);
                if (requiresParameters)
                    writer.Write(", RequiresParameters = true");

                if (isComplex)
                {
                    writer.Write(", IsComplex = true");

                    if (isList)
                    {
                        var itemType = UnwrapListItemType(fieldType, false, out _)?.UnwrapIfNonNull();
                        fieldType = itemType ?? throw ListItemTypeResolutionFailedException(graphQlType.Name, field.Name);
                    }

                    if (fieldType.Kind != GraphQlTypeKind.Scalar && fieldType.Kind != GraphQlTypeKind.Enum && fieldType.Kind != GraphQlTypeKind.List)
                    {
                        var fieldTypeName = fieldType.Name ?? throw FieldTypeResolutionFailedException(graphQlType.Name, field.Name, null);
                        fieldTypeName = context.GetCSharpClassName(fieldTypeName, false);
                        writer.Write(", QueryBuilderType = typeof(");
                        writer.Write(_configuration.ClassPrefix);
                        writer.Write(fieldTypeName);
                        writer.Write("QueryBuilder");
                        writer.Write(_configuration.ClassSuffix);
                        writer.Write(")");
                    }
                }

                writer.Write(" }");
                writer.WriteLine(comma);
            }

            writer.Write(fieldMetadataIndentation);
            writer.WriteLine("    };");
            writer.WriteLine();
        }

        GraphQlDirectiveLocation directiveLocation;
        if (graphQlType.Name == schema.QueryType?.Name)
            directiveLocation = GraphQlDirectiveLocation.Query;
        else if (graphQlType.Name == schema.MutationType?.Name)
            directiveLocation = GraphQlDirectiveLocation.Mutation;
        else if (graphQlType.Name == schema.SubscriptionType?.Name)
            directiveLocation = GraphQlDirectiveLocation.Subscription;
        else
            directiveLocation = GraphQlDirectiveLocation.Field;

        var useCompatibleSyntax = _configuration.CSharpVersion == CSharpVersion.Compatible;

        if (graphQlType.Kind is GraphQlTypeKind.Interface or GraphQlTypeKind.Union)
        {
            const string memberIndentation = "    ";
            writer.Write(indentation);
            writer.Write(memberIndentation);
            writer.Write("public ");
            writer.Write(className);
            writer.Write("()");

            if (useCompatibleSyntax)
            {
                writer.WriteLine();
                writer.Write(indentation);
                writer.Write(memberIndentation);
                writer.WriteLine("{");
                writer.Write(indentation);
                writer.Write(memberIndentation);
                writer.WriteLine("    WithTypeName();");
                writer.Write(indentation);
                writer.Write(memberIndentation);
                writer.WriteLine("}");
            }
            else
                writer.WriteLine(" => WithTypeName();");

            writer.WriteLine();
        }

        var hasQueryPrefix = directiveLocation != GraphQlDirectiveLocation.Field;

        WriteOverrideProperty("protected", "string", "TypeName", $"\"{graphQlType.Name}\"", indentation, writer);

        WriteOverrideProperty("public", "IReadOnlyList<GraphQlFieldMetadata>", "AllFields", "AllFieldMetadata", indentation, writer);

        var stringDataType = AddQuestionMarkIfNullableReferencesEnabled("string");

        if (hasQueryPrefix)
        {
            writer.Write(indentation);
            writer.Write("    public ");
            writer.Write(className);
            writer.Write("(");
            writer.Write(stringDataType);
            writer.Write(" operationName = null) : base(\"");
            writer.Write(directiveLocation.ToString().ToLowerInvariant());
            writer.WriteLine("\", operationName)");
            writer.Write(indentation);
            writer.WriteLine("    {");
            writer.Write(indentation);
            writer.WriteLine("    }");
            writer.WriteLine();

            writer.Write(indentation);
            writer.Write("    public ");
            writer.Write(className);
            writer.Write(" WithParameter<T>(GraphQlQueryParameter<T> parameter)");
            WriteQueryBuilderMethodBody(
                useCompatibleSyntax,
                indentation,
                writer,
                () => writer.WriteLine($"{ReturnPrefix(useCompatibleSyntax)}WithParameterInternal(parameter);"));

            writer.WriteLine();
        }

        var fragments = context.GetFragments(graphQlType);
        fields ??= new List<GraphQlField>();
        var firstFragmentIndex = fields.Count;
        fields.AddRange(fragments);
        var csharpNameLookup = fields.ToLookup(f => NamingHelper.ToPascalCase(f.Name));

        for (var i = 0; i < fields.Count; i++)
        {
            var field = fields[i];
            var fieldType = field.Type.UnwrapIfNonNull();
            if (fieldType.Kind == GraphQlTypeKind.List)
                fieldType = UnwrapListItemType(fieldType, false, out _);

            fieldType = fieldType.UnwrapIfNonNull();
            var isFragment = i >= firstFragmentIndex;
            var argumentDefinitions = ResolveParameterDefinitions(context, graphQlType, field.Args);
            var argumentCollectionVariableName = "args";
            var counter = 0;
            while (argumentDefinitions.Any(a => a.NetParameterName == argumentCollectionVariableName))
                switch (argumentCollectionVariableName)
                {
                    case "args":
                        argumentCollectionVariableName = "inputArgs";
                        break;

                    default:
                        argumentCollectionVariableName = $"inputArgs{(counter == 0 ? null : counter)}";
                        counter++;
                        break;
                }

            var methodParameters =
                String.Join(
                    ", ",
                    argumentDefinitions
                        .OrderByDescending(d => d.Argument.Type.Kind == GraphQlTypeKind.NonNull)
                        .Select(d => d.NetParameterDefinitionClause));

            var requiresFullBody = useCompatibleSyntax || argumentDefinitions.Any();
            var returnPrefix = ReturnPrefix(requiresFullBody);
            var csharpPropertyName = NamingHelper.ToPascalCase(field.Name);
            var requiresRawName = csharpNameLookup[csharpPropertyName].Count() > 1;
            if (requiresRawName)
                csharpPropertyName = field.Name;

            if (field.IsDeprecated)
            {
                WriteObsoleteAttribute(writer, field.DeprecationReason, indentation);
            }

            if (fieldType.Kind is GraphQlTypeKind.Scalar or GraphQlTypeKind.Enum or GraphQlTypeKind.List)
            {
                writer.Write(indentation);
                writer.Write("    public ");
                writer.Write(className);
                writer.Write(" With");
                writer.Write(csharpPropertyName);
                writer.Write("(");
                writer.Write(methodParameters);

                if (!String.IsNullOrEmpty(methodParameters))
                    writer.Write(", ");

                WriteAliasParameter();

                var fieldDirectiveParameterNameList = WriteDirectiveParameterList(schema, argumentDefinitions, GraphQlDirectiveLocation.Field, writer);

                writer.Write(")");

                WriteQueryBuilderMethodBody(
                    requiresFullBody,
                    indentation,
                    writer,
                    () =>
                    {
                        AppendArgumentDictionary(indentation, writer, argumentDefinitions, argumentCollectionVariableName);

                        writer.Write(returnPrefix);
                        writer.Write("WithScalarField(\"");
                        writer.Write(field.Name);
                        writer.Write("\", alias, ");
                        writer.Write(fieldDirectiveParameterNameList);

                        if (argumentDefinitions.Count > 0)
                        {
                            writer.Write(", ");
                            writer.Write(argumentCollectionVariableName);
                        }

                        writer.WriteLine(");");
                    });
            }
            else
            {
                var fieldTypeName = fieldType.Name;
                if (String.IsNullOrEmpty(fieldTypeName))
                    throw FieldTypeResolutionFailedException(graphQlType.Name, field.Name, null);

                fieldTypeName = context.GetCSharpClassName(fieldTypeName, false);

                var builderParameterName = NamingHelper.LowerFirst(fieldTypeName);
                writer.Write(indentation);
                writer.Write("    public ");
                writer.Write(className);
                writer.Write(" With");
                writer.Write(csharpPropertyName);

                if (isFragment)
                    writer.Write("Fragment");

                writer.Write('(');
                writer.Write(_configuration.ClassPrefix);
                writer.Write(fieldTypeName);
                writer.Write("QueryBuilder");
                writer.Write(_configuration.ClassSuffix);
                writer.Write(' ');
                writer.Write(builderParameterName);
                writer.Write("QueryBuilder");

                if (argumentDefinitions.Count > 0)
                {
                    writer.Write(", ");
                    writer.Write(methodParameters);
                }

                if (!isFragment)
                {
                    writer.Write(", ");
                    WriteAliasParameter();
                }

                var fieldDirectiveParameterNameList = WriteDirectiveParameterList(schema, argumentDefinitions, GraphQlDirectiveLocation.Field, writer);

                writer.Write(")");

                WriteQueryBuilderMethodBody(
                    requiresFullBody,
                    indentation,
                    writer,
                    () =>
                    {
                        AppendArgumentDictionary(indentation, writer, argumentDefinitions, argumentCollectionVariableName);

                        writer.Write(returnPrefix);
                        writer.Write("With");

                        if (isFragment)
                            writer.Write("Fragment(");
                        else
                        {
                            writer.Write("ObjectField(\"");
                            writer.Write(field.Name);
                            writer.Write("\", alias, ");
                        }

                        writer.Write(builderParameterName);
                        writer.Write("QueryBuilder");

                        writer.Write(", ");
                        writer.Write(fieldDirectiveParameterNameList);

                        if (argumentDefinitions.Count > 0)
                        {
                            writer.Write(", ");
                            writer.Write(argumentCollectionVariableName);
                        }

                        writer.WriteLine(");");
                    });
            }

            if (!isFragment)
            {
                writer.WriteLine();

                writer.Write(indentation);
                writer.Write("    public ");
                writer.Write(className);
                writer.Write(" Except");
                writer.Write(csharpPropertyName);
                writer.Write("()");

                WriteQueryBuilderMethodBody(
                    useCompatibleSyntax,
                    indentation,
                    writer,
                    () => writer.WriteLine($"{ReturnPrefix(useCompatibleSyntax)}ExceptField(\"{field.Name}\");"));
            }

            if (i < fields.Count - 1)
                writer.WriteLine();

            continue;

            void WriteAliasParameter()
            {
                writer.Write(stringDataType);
                writer.Write(" alias = ");

                if (_configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.UseDefaultAlias && !String.Equals(field.Name, csharpPropertyName, StringComparison.OrdinalIgnoreCase))
                {
                    writer.Write('"');
                    writer.Write(NamingHelper.LowerFirst(csharpPropertyName));
                    writer.Write('"');
                }
                else
                    writer.Write("null");
            }
        }

        writer.Write(indentation);
        writer.WriteLine("}");

        context.AfterQueryBuilderGeneration(
            new ObjectGenerationContext
            {
                GraphQlType = graphQlType,
                CSharpTypeName = className
            });

        return;

        string ReturnPrefix(bool requiresFullBody) => requiresFullBody ? $"{indentation}        return " : String.Empty;
    }

    private static void WriteObsoleteAttribute(TextWriter writer, string deprecationReason, string indentation)
    {
        deprecationReason = String.IsNullOrWhiteSpace(deprecationReason) ? null : $"(@\"{deprecationReason.Replace("\"", "\"\"")}\")";
        writer.Write(indentation);
        writer.WriteLine($"    [Obsolete{deprecationReason}]");
    }

    private IList<QueryBuilderParameterDefinition> ResolveParameterDefinitions(GenerationContext context, GraphQlType type, IEnumerable<GraphQlArgument> graphQlArguments)
    {
        if (graphQlArguments is null)
            return Array.Empty<QueryBuilderParameterDefinition>();

        var parameterDefinitions = new List<QueryBuilderParameterDefinition>();
        var collidingNames = new Dictionary<string, int>();
        foreach (var argument in graphQlArguments.Where(a => IsCompatibleArgument(a.Type)))
        {
            var netParameterName = NamingHelper.ToValidCSharpName(NamingHelper.LowerFirst(NamingHelper.ToPascalCase(argument.Name)));
            collidingNames[netParameterName] = collidingNames.TryGetValue(netParameterName, out var extendingIndex) ? extendingIndex + 1 : 1;

            if (extendingIndex > 0)
                netParameterName = $"{netParameterName}{++extendingIndex}";

            parameterDefinitions.Add(BuildMethodParameterDefinition(context, type, argument, netParameterName));
        }

        return parameterDefinitions;

        static bool IsCompatibleArgument(GraphQlFieldType argumentType)
        {
            argumentType = argumentType.UnwrapIfNonNull();
            return
                argumentType.Kind switch
                {
                    GraphQlTypeKind.Scalar => true,
                    GraphQlTypeKind.Enum => true,
                    GraphQlTypeKind.InputObject => true,
                    GraphQlTypeKind.List => IsCompatibleArgument(argumentType.OfType),
                    _ => false
                };
        }
    }

    internal static GraphQlFieldType UnwrapListItemType(GraphQlFieldType type, bool nullableReferencesEnabled, out string netCollectionOpenType)
    {
        var levels = 0;

        var nullableSymbols = new List<string> { String.Empty };

        while (true)
        {
            levels++;

            var unwrappedType = type.OfType?.UnwrapIfNonNull();
            if (unwrappedType is null)
            {
                netCollectionOpenType = null;
                return null;
            }

            if (unwrappedType.Kind != GraphQlTypeKind.List)
            {
                type = type.OfType;
                break;
            }

            nullableSymbols.Add(type.OfType.Kind == GraphQlTypeKind.NonNull ? String.Empty : nullableReferencesEnabled ? "?" : String.Empty);
            type = unwrappedType;
        }

        nullableSymbols.Reverse();

        netCollectionOpenType =
            levels == 1
                ? "ICollection<{0}>"
                : String.Concat(Enumerable.Repeat("IList<", levels).Append("{0}").Concat(nullableSymbols.Select(s => $">{s}")));

        return type;
    }

    private string WriteDirectiveParameterList(GraphQlSchema schema, IEnumerable<QueryBuilderParameterDefinition> argumentDefinitions, GraphQlDirectiveLocation directiveLocation, TextWriter writer)
    {
        var argumentNames = new HashSet<string>(argumentDefinitions.Select(ad => ad.NetParameterName));
        var directiveParameterNames = new List<string>();

        foreach (var directive in schema.Directives.Where(d => d.Locations.Contains(directiveLocation)))
        {
            var csharpDirectiveName = NamingHelper.ToPascalCase(directive.Name);
            var directiveClassName = $"{csharpDirectiveName}Directive";
            var directiveParameterName = NamingHelper.LowerFirst(csharpDirectiveName);

            if (argumentNames.Contains(directiveParameterName))
            {
                directiveParameterName += "Directive";

                if (argumentNames.Contains(directiveParameterName))
                {
                    directiveParameterName += "Value";

                    var parameterCounter = 0;
                    var directiveParameterNameWithCounter = directiveParameterName;
                    while (argumentNames.Contains(directiveParameterNameWithCounter))
                        directiveParameterNameWithCounter = directiveParameterName + ++parameterCounter;

                    directiveParameterName = directiveParameterNameWithCounter;
                }
            }

            directiveParameterNames.Add(directiveParameterName);

            writer.Write(", ");
            writer.Write(AddQuestionMarkIfNullableReferencesEnabled(directiveClassName));
            writer.Write(" ");
            writer.Write(directiveParameterName);
            writer.Write(" = null");
        }

        return
            directiveParameterNames.Any()
                ? $"new {AddQuestionMarkIfNullableReferencesEnabled("GraphQlDirective")}[] {{ {String.Join(", ", directiveParameterNames)} }}"
                : "null";
    }

    private static void WriteQueryBuilderMethodBody(bool requiresFullBody, string indentation, TextWriter writer, Action writeBody)
    {
        if (requiresFullBody)
        {
            writer.WriteLine();
            writer.Write(indentation);
            writer.WriteLine("    {");
        }
        else
            writer.Write(" => ");

        writeBody();

        if (requiresFullBody)
        {
            writer.Write(indentation);
            writer.WriteLine("    }");
        }
    }

    private void WriteOverrideProperty(string accessibility, string propertyType, string propertyName, string propertyValue, string indentation, TextWriter writer)
    {
        writer.Write(indentation);
        writer.Write("    ");
        writer.Write(accessibility);
        writer.Write(" override ");
        writer.Write(propertyType);
        writer.Write(" ");
        writer.Write(propertyName);
        writer.Write(" { get");

        if (_configuration.CSharpVersion == CSharpVersion.Compatible)
        {
            writer.Write(" { return ");
            writer.Write(propertyValue);
            writer.WriteLine("; } } ");
        }
        else
        {
            writer.Write("; } = ");
            writer.Write(propertyValue);
            writer.WriteLine(";");
        }

        writer.WriteLine();
    }

    private QueryBuilderParameterDefinition BuildMethodParameterDefinition(GenerationContext context, GraphQlType baseType, GraphQlArgument argument, string netParameterName)
    {
        var argumentType = argument.Type;
        var isArgumentNotNull = argumentType.Kind == GraphQlTypeKind.NonNull;
        var isTypeNotNull = isArgumentNotNull;
        var unwrappedType = argumentType.UnwrapIfNonNull();
        var isCollection = unwrappedType.Kind == GraphQlTypeKind.List;
        if (isCollection)
        {
            isTypeNotNull = unwrappedType.OfType.Kind == GraphQlTypeKind.NonNull;
            argumentType = unwrappedType.OfType;
            unwrappedType = argumentType.UnwrapIfNonNull();
        }

        var argumentTypeDescription =
            unwrappedType.Kind == GraphQlTypeKind.Enum
                ? ScalarFieldTypeDescription.FromNetTypeName($"{_configuration.ClassPrefix}{NamingHelper.ToPascalCase(unwrappedType.Name)}{_configuration.ClassSuffix}?")
                : context.ResolveScalarNetType(baseType, argument.Name, argumentType);

        var argumentNetType = argumentTypeDescription.NetTypeName;

        if (isTypeNotNull)
            argumentNetType = argumentNetType.TrimEnd('?');

        var isInputObject = unwrappedType.Kind == GraphQlTypeKind.InputObject;
        if (isInputObject)
        {
            argumentNetType = context.GetCSharpClassName(unwrappedType.Name);
            argumentNetType = $"{_configuration.ClassPrefix}{argumentNetType}{_configuration.ClassSuffix}";

            if (!isTypeNotNull)
                argumentNetType = AddQuestionMarkIfNullableReferencesEnabled(argumentNetType);
        }

        argumentNetType = isCollection ? $"QueryBuilderParameter<IEnumerable<{argumentNetType}>>" : $"QueryBuilderParameter<{argumentNetType}>";

        if (!isArgumentNotNull)
            argumentNetType = AddQuestionMarkIfNullableReferencesEnabled(argumentNetType);

        var argumentDefinition = $"{argumentNetType} {netParameterName}";
        if (!isArgumentNotNull)
            argumentDefinition = $"{argumentDefinition} = null";

        return
            new QueryBuilderParameterDefinition
            {
                Argument = argument,
                IsNullable = !isArgumentNotNull,
                NetParameterName = netParameterName,
                NetParameterDefinitionClause = argumentDefinition,
                FormatMask = argumentTypeDescription.FormatMask
            };
    }

    private static void AppendArgumentDictionary(string indentation, TextWriter writer, ICollection<QueryBuilderParameterDefinition> argumentDefinitions, string argumentCollectionVariableName)
    {
        if (argumentDefinitions.Count == 0)
            return;

        writer.Write(indentation);
        writer.Write("        var ");
        writer.Write(argumentCollectionVariableName);
        writer.WriteLine(" = new List<QueryBuilderArgumentInfo>();");

        foreach (var argumentDefinition in argumentDefinitions)
        {
            writer.Write(indentation);

            if (argumentDefinition.Argument.Type.Kind == GraphQlTypeKind.NonNull)
            {
                writer.Write("        ");
                WriteAddKeyValuePair(writer, argumentDefinition, argumentCollectionVariableName);
            }
            else
            {
                writer.Write("        if (");
                writer.Write(argumentDefinition.NetParameterName);
                writer.WriteLine(" != null)");
                writer.Write(indentation);
                writer.Write("            ");
                WriteAddKeyValuePair(writer, argumentDefinition, argumentCollectionVariableName);
                writer.WriteLine();
            }
        }

        return;

        static void WriteAddKeyValuePair(TextWriter writer, QueryBuilderParameterDefinition argumentDefinition, string variableName)
        {
            var argument = argumentDefinition.Argument;
            writer.Write(variableName);
            writer.Write(".Add(new QueryBuilderArgumentInfo { ArgumentName = \"");
            writer.Write(argument.Name);
            writer.Write("\", ArgumentValue = ");
            writer.Write(argumentDefinition.NetParameterName);

            if (!String.IsNullOrEmpty(argumentDefinition.FormatMask))
            {
                writer.Write(", FormatMask = \"");
                writer.Write(argumentDefinition.FormatMask.Replace("\"", "\\\""));
                writer.Write("\"");
            }

            writer.WriteLine("} );");
        }
    }

    private void GenerateEnum(GenerationContext context, GraphQlType graphQlType)
    {
        var enumName = $"{_configuration.ClassPrefix}{NamingHelper.ToPascalCase(graphQlType.Name)}{_configuration.ClassSuffix}";

        context.BeforeEnumGeneration(
            new ObjectGenerationContext
            {
                GraphQlType = graphQlType,
                CSharpTypeName = enumName
            });

        var writer = context.Writer;

        GenerateCodeComments(writer, graphQlType.Description, context.Indentation);
        var indentation = GetIndentation(context.Indentation);
        writer.Write(indentation);
        writer.Write("public enum ");
        writer.WriteLine(enumName);
        writer.Write(indentation);
        writer.WriteLine("{");

        var enumValues = graphQlType.EnumValues.ToList();
        for (var i = 0; i < enumValues.Count; i++)
        {
            var enumValue = enumValues[i];
            GenerateCodeComments(writer, enumValue.Description, context.Indentation + 4);
            writer.Write(indentation);
            writer.Write("    ");

            var useCSharpNaming = _configuration.EnumValueNaming == EnumValueNamingOption.CSharp;
            var netIdentifier =
                useCSharpNaming
                    ? NamingHelper.ToCSharpEnumName(enumValue.Name)
                    : NamingHelper.ToValidCSharpName(enumValue.Name);

            if (useCSharpNaming && netIdentifier != enumValue.Name)
            {
                writer.Write("[EnumMember(Value = \"");
                writer.Write(enumValue.Name);
                writer.Write("\")] ");
            }

            writer.Write(netIdentifier);

            if (i < enumValues.Count - 1)
                writer.Write(",");

            writer.WriteLine();
        }

        writer.Write(indentation);
        writer.WriteLine("}");

        context.AfterEnumGeneration(
            new ObjectGenerationContext
            {
                GraphQlType = graphQlType,
                CSharpTypeName = enumName
            });
    }

    private static readonly HashSet<GraphQlDirectiveLocation> SupportedDirectiveLocations =
        new()
        {
            GraphQlDirectiveLocation.Object,
            GraphQlDirectiveLocation.Field,
            GraphQlDirectiveLocation.Query,
            GraphQlDirectiveLocation.Mutation,
            GraphQlDirectiveLocation.Subscription
        };

    private void GenerateDirectives(GenerationContext context)
    {
        if (IsQueryBuilderGenerationDisabled(context.ObjectTypes))
            return;

        var queryBuilderDirectives = context.Schema.Directives.Where(t => SupportedDirectiveLocations.Overlaps(t.Locations)).ToList();
        if (!queryBuilderDirectives.Any())
            return;

        context.BeforeDirectivesGeneration();

        queryBuilderDirectives.ForEach(d => GenerateDirective(context, d));

        context.AfterDirectivesGeneration();
    }

    private void GenerateDirective(GenerationContext context, GraphQlDirective directive)
    {
        var directiveName = $"{NamingHelper.ToPascalCase(directive.Name)}Directive";

        context.BeforeDirectiveGeneration(directiveName);

        var writer = context.Writer;

        GenerateCodeComments(writer, directive.Description, context.Indentation);

        var orderedArgumentDefinitions =
            ResolveParameterDefinitions(
                context,
                new GraphQlType { Name = directive.Name, Description = directive.Description, InputFields = directive.Args } /* TODO: make some common ancestor */,
                directive.Args.OrderByDescending(a => a.Type.Kind == GraphQlTypeKind.NonNull));

        var argumentList = String.Join(", ", orderedArgumentDefinitions.Select(d => d.NetParameterDefinitionClause));

        var indentation = GetIndentation(context.Indentation);
        writer.Write(indentation);
        writer.Write("public class ");
        writer.Write(directiveName);
        writer.WriteLine(" : GraphQlDirective");
        writer.Write(indentation);
        writer.WriteLine("{");
        writer.Write(indentation);
        writer.Write("    public ");
        writer.Write(directiveName);
        writer.Write("(");
        writer.Write(argumentList);
        writer.Write(") : base(\"");
        writer.Write(directive.Name);
        writer.WriteLine("\")");
        writer.Write(indentation);
        writer.WriteLine("    {");

        foreach (var definition in orderedArgumentDefinitions)
        {
            writer.Write(indentation);
            writer.Write("        AddArgument(\"");
            writer.Write(definition.Argument.Name);
            writer.Write("\", ");
            writer.Write(definition.NetParameterName);
            writer.WriteLine(");");
        }

        writer.Write(indentation);
        writer.WriteLine("    }");
        writer.Write(indentation);
        writer.WriteLine("}");

        context.AfterDirectiveGeneration(directiveName);
    }

    private void GenerateCodeComments(TextWriter writer, string description, int indentationSize)
    {
        if (String.IsNullOrWhiteSpace(description))
            return;

        var indentation = GetIndentation(indentationSize);

        if (_configuration.CommentGeneration.HasFlag(CommentGenerationOption.CodeSummary))
        {
            writer.Write(indentation);
            writer.WriteLine("/// <summary>");
            writer.Write(indentation);
            writer.Write("/// ");
            writer.WriteLine(String.Join($"{Environment.NewLine}{indentation}/// ", description.Split('\n').Select(l => l.Trim())));
            writer.Write(indentation);
            writer.WriteLine("/// </summary>");
        }

        if (_configuration.CommentGeneration.HasFlag(CommentGenerationOption.DescriptionAttribute))
        {
            writer.Write(indentation);
            writer.WriteLine($"[Description(@\"{description.Replace("\"", "\"\"")}\")]");
        }
    }

    public static string GetIndentation(int size) => new(' ', size);

    private struct QueryBuilderParameterDefinition
    {
        public GraphQlArgument Argument;
        public bool IsNullable;
        public string NetParameterName;
        public string NetParameterDefinitionClause;
        public string FormatMask;
    }

    private struct DataPropertyContext
    {
        public IGraphQlMember Member;
        public string PropertyName;
        public bool IsDeprecated;
        public string DeprecationReason;
        public bool DecorateWithJsonPropertyAttribute;
        public bool RequiresRawName;
    }
}
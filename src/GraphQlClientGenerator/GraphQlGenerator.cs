using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Serialization;

namespace GraphQlClientGenerator
{
    public class GraphQlGenerator
    {
        private const string AutoGeneratedPrefix = "// <auto-generated> This file has been auto generated. </auto-generated>";

        public const string PreprocessorDirectiveDisableNewtonsoftJson = "GRAPHQL_GENERATOR_DISABLE_NEWTONSOFT_JSON";

        public const string RequiredNamespaces =
            @"using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
#if !" + PreprocessorDirectiveDisableNewtonsoftJson + @"
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
#endif
";

        private delegate void WriteDataClassPropertyBodyDelegate(ScalarFieldTypeDescription netType, string backingFieldName);

        private static readonly HttpClient HttpClient =
            new()
            {
                DefaultRequestHeaders =
                {
                    UserAgent = { ProductInfoHeaderValue.Parse("GraphQlClientGenerator/" + typeof(GraphQlGenerator).GetTypeInfo().Assembly.GetName().Version) }
                }
            };

        internal static readonly JsonSerializerSettings SerializerSettings =
            new()
            {
                ContractResolver = new CamelCasePropertyNamesContractResolver(),
                Converters = { new StringEnumConverter() }
            };

        private readonly GraphQlGeneratorConfiguration _configuration;

        public GraphQlGenerator(GraphQlGeneratorConfiguration configuration = null)
        {
            _configuration = configuration ?? new GraphQlGeneratorConfiguration();
        }

        public static async Task<GraphQlSchema> RetrieveSchema(string url, bool HttpGet, IEnumerable<KeyValuePair<string, string>> headers = null)
        {
            using var request =
                new HttpRequestMessage(HttpGet ? HttpMethod.Get : HttpMethod.Post, url)
                {
                    Content = new StringContent(JsonConvert.SerializeObject(new { query = IntrospectionQuery.Text }), Encoding.UTF8, "application/json")
                };

            if (headers != null)
                foreach (var kvp in headers)
                    request.Headers.TryAddWithoutValidation(kvp.Key, kvp.Value);

            using var response = await HttpClient.SendAsync(request);

            var content =
                response.Content == null
                    ? "(no content)"
                    : await response.Content.ReadAsStringAsync();

            if (!response.IsSuccessStatusCode)
                throw new InvalidOperationException($"Status code: {(int)response.StatusCode} ({response.StatusCode}){Environment.NewLine}content:{Environment.NewLine}{content}");

            return DeserializeGraphQlSchema(content);
        }

        public static GraphQlSchema DeserializeGraphQlSchema(string content)
        {
            try
            {
                var schema =
                    JsonConvert.DeserializeObject<GraphQlResult>(content, SerializerSettings)?.Data?.Schema
                    ?? JsonConvert.DeserializeObject<GraphQlData>(content, SerializerSettings)?.Schema;

                if (schema == null)
                    throw new ArgumentException("not a GraphQL schema", nameof(content));

                return schema;
            }
            catch (JsonReaderException exception)
            {
                throw new ArgumentException("not a GraphQL schema", nameof(content), exception);
            }
        }

        public string GenerateFullClientCSharpFile(GraphQlSchema schema, string @namespace)
        {
            var builder = new StringBuilder();
            using var writer = new StringWriter(builder);
            WriteFullClientCSharpFile(schema, @namespace, writer);
            return builder.ToString();
        }

        public void WriteFullClientCSharpFile(GraphQlSchema schema, string @namespace, TextWriter writer)
        {
            if (String.IsNullOrWhiteSpace(@namespace))
                throw new ArgumentException("namespace required", nameof(@namespace));

            var namespaceElements = @namespace.Split('.');
            if (namespaceElements.Any(e => !CSharpHelper.IsValidIdentifier(e)))
                throw new ArgumentException("invalid namespace: " + @namespace, nameof(@namespace));

            writer.WriteLine(AutoGeneratedPrefix);
            writer.WriteLine();
            writer.WriteLine(RequiredNamespaces);
            writer.Write("namespace ");
            writer.WriteLine(@namespace);
            writer.WriteLine("{");

            Generate(new SingleFileGenerationContext(schema, writer, indentationSize: 4));

            writer.WriteLine("}");
            writer.Flush();
        }

        public string Generate(GraphQlSchema schema)
        {
            var builder = new StringBuilder();
            using var writer = new StringWriter(builder);
            Generate(new SingleFileGenerationContext(schema, writer));
            return builder.ToString();
        }

        public void Generate(GenerationContext context)
        {
            context.BeforeGeneration(_configuration);

            GenerateBaseClasses(context);

            GenerateGraphQlTypeNames(context);

            GenerateEnums(context);

            GenerateDirectives(context);

            GenerateQueryBuilders(context);

            var referencedObjectTypes = GenerateInputObjects(context);

            GenerateDataClasses(context, referencedObjectTypes);

            context.AfterGeneration();
        }

        private void GenerateGraphQlTypeNames(GenerationContext context)
        {
            context.BeforeGraphQlTypeNameGeneration();

            var indentation = GetIndentation(context.Indentation);
            var writer = context.Writer;
            writer.Write(indentation);
            writer.WriteLine("public static class GraphQlTypes");
            writer.Write(indentation);
            writer.WriteLine("{");

            var graphQlTypes = context.Schema.Types.Where(t => !t.Name.StartsWith("__")).OrderBy(t => t.Kind).ThenBy(t => t.Name).ToArray();
            GraphQlType precedingInputObjectType = null;
            foreach (var inputObjectType in graphQlTypes)
            {
                if (precedingInputObjectType != null && inputObjectType.Kind != precedingInputObjectType.Kind)
                    writer.WriteLine();

                writer.Write(indentation);
                writer.Write("    public const string ");
                writer.Write(NamingHelper.ToPascalCase(inputObjectType.Name));
                writer.Write(" = \"");
                writer.Write(inputObjectType.Name);
                writer.WriteLine("\";");

                precedingInputObjectType = inputObjectType;
            }

            writer.WriteLine();
            writer.Write(indentation);
            writer.WriteLine("    public static readonly IReadOnlyDictionary<Type, string> ReverseMapping =");
            writer.Write(indentation);
            writer.WriteLine("        new Dictionary<Type, string>");
            writer.Write(indentation);
            writer.WriteLine("        {");

            var netTypeKeys = new HashSet<string>();
            string typeMappingSeparator = null;

            void WriteMappingEntry(string netType, string graphQlTypeName)
            {
                if (!netTypeKeys.Add(netType))
                    return;

                if (typeMappingSeparator != null)
                    writer.WriteLine(typeMappingSeparator);

                writer.Write(indentation);
                writer.Write("            { typeof(");
                writer.Write(netType);
                writer.Write("), \"");
                writer.Write(graphQlTypeName);
                writer.Write("\" }");

                typeMappingSeparator = ",";
            }

            foreach (var type in graphQlTypes.Where(t => t.Kind == GraphQlTypeKind.Object || t.Kind == GraphQlTypeKind.InputObject))
            {
                if (type.Kind == GraphQlTypeKind.InputObject)
                {
                    var netType = _configuration.ClassPrefix + NamingHelper.ToPascalCase(type.Name) + _configuration.ClassSuffix;
                    WriteMappingEntry(netType, type.Name);
                }
                else
                {
                    foreach (var member in type.Kind == GraphQlTypeKind.Object ? (IEnumerable<IGraphQlMember>)type.Fields : type.InputFields)
                    {
                        var fieldType = member.Type.UnwrapIfNonNull();
                        if (fieldType.Kind == GraphQlTypeKind.List)
                        {
                            var itemType = UnwrapListItemType(fieldType, out _);
                            fieldType = itemType?.UnwrapIfNonNull();
                            if (fieldType == null)
                                continue;
                        }

                        if (fieldType.Kind != GraphQlTypeKind.Scalar)
                            continue;

                        var netType = GetScalarNetType(fieldType.Name, type, member).NetTypeName.Trim().TrimEnd('?');
                        if (netType.EndsWith("object") || netType.EndsWith("System.Object"))
                            continue;

                        WriteMappingEntry(netType, fieldType.Name);
                    }
                }
            }

            writer.WriteLine();
            writer.Write(indentation);
            writer.WriteLine("        };");

            writer.WriteLine("}");

            context.AfterGraphQlTypeNameGeneration();
        }

        private void GenerateEnums(GenerationContext context)
        {
            var enumTypes = context.Schema.Types.Where(t => t.Kind == GraphQlTypeKind.Enum && !t.Name.StartsWith("__")).ToList();
            if (!enumTypes.Any())
                return;

            context.BeforeEnumsGeneration();

            enumTypes.ForEach(t => GenerateEnum(context, t));

            context.AfterEnumsGeneration();
        }

        private void GenerateQueryBuilders(GenerationContext context)
        {
            if (IsQueryBuilderGenerationDisabled(context.ObjectTypes))
                return;

            context.BeforeQueryBuildersGeneration();

            var complexTypes = context.Schema.Types.Where(t => IsComplexType(t.Kind) && !t.Name.StartsWith("__")).ToList();
            var complexTypeDictionary = complexTypes.ToDictionary(t => t.Name);
            complexTypes.ForEach(t => GenerateQueryBuilder(context, t, complexTypeDictionary));

            context.AfterQueryBuildersGeneration();
        }

        private static void GenerateBaseClasses(GenerationContext context)
        {
            if (IsQueryBuilderGenerationDisabled(context.ObjectTypes))
                return;

            context.BeforeBaseClassGeneration();

            var indentation = GetIndentation(context.Indentation);

            using var reader = new StreamReader(typeof(GraphQlGenerator).GetTypeInfo().Assembly.GetManifestResourceStream("GraphQlClientGenerator.BaseClasses.cs"));
            do
            {
                var line = reader.ReadLine();
                if (line == null)
                    break;

                context.Writer.Write(indentation);
                context.Writer.WriteLine(line.Replace("GRAPHQL_GENERATOR_DISABLE_NEWTONSOFT_JSON", PreprocessorDirectiveDisableNewtonsoftJson));
            } while (true);

            context.AfterBaseClassGeneration();
        }

        private static bool IsQueryBuilderGenerationDisabled(GeneratedObjectType objectTypes) => !objectTypes.HasFlag(GeneratedObjectType.QueryBuilders);

        private static bool IsDataClassGenerationDisabled(GeneratedObjectType objectTypes) => !objectTypes.HasFlag(GeneratedObjectType.DataClasses);

        private static string GetIndentation(int size) => new(' ', size);

        private static void FindAllReferencedObjectTypes(GraphQlSchema schema, GraphQlType type, ISet<string> objectTypes)
        {
            foreach (var member in (IEnumerable<IGraphQlMember>)type.InputFields ?? type.Fields)
            {
                var unwrappedType = member.Type.UnwrapIfNonNull();
                GraphQlType memberType;
                switch (unwrappedType.Kind)
                {
                    case GraphQlTypeKind.Object:
                        objectTypes.Add(unwrappedType.Name);
                        memberType = schema.Types.Single(t => t.Name == unwrappedType.Name);
                        FindAllReferencedObjectTypes(schema, memberType, objectTypes);
                        break;

                    case GraphQlTypeKind.List:
                        var itemType = unwrappedType.OfType.UnwrapIfNonNull();
                        if (IsComplexType(itemType.Kind))
                        {
                            memberType = schema.Types.Single(t => t.Name == itemType.Name);
                            FindAllReferencedObjectTypes(schema, memberType, objectTypes);
                        }

                        break;
                }
            }
        }

        private ICollection<string> GenerateInputObjects(GenerationContext context)
        {
            var referencedObjectTypes = new HashSet<string>();
            if (IsDataClassGenerationDisabled(context.ObjectTypes))
                return referencedObjectTypes;

            var schema = context.Schema;
            var inputObjectTypes = schema.Types.Where(t => t.Kind == GraphQlTypeKind.InputObject && !t.Name.StartsWith("__")).ToArray();
            if (!inputObjectTypes.Any())
                return referencedObjectTypes;

            context.BeforeInputClassesGeneration();

            foreach (var inputObjectType in inputObjectTypes)
            {
                FindAllReferencedObjectTypes(schema, inputObjectType, referencedObjectTypes);
                GenerateDataClass(
                    context,
                    NamingHelper.ToPascalCase(inputObjectType.Name),
                    inputObjectType,
                    "IGraphQlInputObject",
                    () => GenerateInputDataClassBody(inputObjectType, inputObjectType.InputFields.Cast<IGraphQlMember>().ToArray(), context));
            }

            context.AfterInputClassesGeneration();
            return referencedObjectTypes;
        }

        private void GenerateDataClasses(GenerationContext context, ICollection<string> referencedObjectTypes)
        {
            if (IsDataClassGenerationDisabled(context.ObjectTypes))
                return;

            var schema = context.Schema;
            var complexTypes = schema.Types.Where(t => IsComplexType(t.Kind) && !t.Name.StartsWith("__")).ToArray();
            if (!complexTypes.Any())
                return;

            var complexTypeDictionary = complexTypes.ToDictionary(t => t.Name);

            context.BeforeDataClassesGeneration();

            foreach (var complexType in complexTypes)
            {
                var hasInputReference = referencedObjectTypes.Contains(complexType.Name);
                var fieldsToGenerate = GetFieldsToGenerate(complexType, complexTypeDictionary);
                var isInterface = complexType.Kind == GraphQlTypeKind.Interface;
                var csharpTypeName = complexType.Name;
                if (!UseCustomClassNameIfDefined(ref csharpTypeName))
                    csharpTypeName = NamingHelper.ToPascalCase(csharpTypeName);

                void GenerateBody(bool isInterfaceMember)
                {
                    var writer = context.Writer;
                    if (hasInputReference)
                        GenerateInputDataClassBody(complexType, fieldsToGenerate, context);
                    else if (fieldsToGenerate != null)
                    {
                        var generateBackingFields = _configuration.PropertyGeneration == PropertyGenerationOption.BackingField && !isInterfaceMember;
                        if (generateBackingFields)
                        {
                            var indentation = GetIndentation(context.Indentation);

                            foreach (var field in fieldsToGenerate)
                            {
                                writer.Write(indentation);
                                writer.Write("    private ");
                                writer.Write(GetDataPropertyType(complexType, field).NetTypeName);
                                writer.Write(" ");
                                writer.Write(GetBackingFieldName(field.Name));
                                writer.WriteLine(";");
                            }

                            writer.WriteLine();
                        }

                        foreach (var field in fieldsToGenerate)
                            GenerateDataProperty(
                                complexType,
                                field,
                                isInterfaceMember,
                                field.IsDeprecated,
                                field.DeprecationReason,
                                true,
                                (_, backingFieldName) =>
                                    writer.Write(generateBackingFields ? _configuration.PropertyAccessorBodyWriter(backingFieldName, GetDataPropertyType(complexType, field)) : " { get; set; }"),
                                context);
                    }
                }

                var interfacesToImplement = new List<string>();
                if (isInterface)
                {
                    interfacesToImplement.Add(GenerateInterface(context, csharpTypeName, complexType, () => GenerateBody(true)));
                }
                else if (complexType.Interfaces?.Count > 0)
                {
                    var fieldNames = new HashSet<string>(fieldsToGenerate.Select(f => f.Name));

                    foreach (var @interface in complexType.Interfaces)
                    {
                        var interfaceName = "I" + _configuration.ClassPrefix + @interface.Name + _configuration.ClassSuffix;
                        interfacesToImplement.Add(interfaceName);

                        foreach (var interfaceField in complexTypeDictionary[@interface.Name].Fields.Where(FilterDeprecatedFields))
                            if (fieldNames.Add(interfaceField.Name))
                                fieldsToGenerate.Add(interfaceField);
                    }
                }

                if (hasInputReference)
                    interfacesToImplement.Add("IGraphQlInputObject");

                if (!isInterface)
                    GenerateDataClass(context, csharpTypeName, complexType, String.Join(", ", interfacesToImplement), () => GenerateBody(false));
            }

            context.AfterDataClassesGeneration();
        }

        private static string GetBackingFieldName(string graphQlFieldName) => "_" + NamingHelper.LowerFirst(NamingHelper.ToPascalCase(graphQlFieldName));

        private static bool IsComplexType(GraphQlTypeKind graphQlTypeKind) =>
            graphQlTypeKind == GraphQlTypeKind.Object || graphQlTypeKind == GraphQlTypeKind.Interface || graphQlTypeKind == GraphQlTypeKind.Union;

        private void GenerateInputDataClassBody(GraphQlType type, IEnumerable<IGraphQlMember> members, GenerationContext context)
        {
            var writer = context.Writer;
            var indentation = GetIndentation(context.Indentation);

            var fieldNameMembers = new Dictionary<string, IGraphQlMember>();
            foreach (var member in members)
            {
                var fieldName = GetBackingFieldName(member.Name);
                fieldNameMembers.Add(fieldName, member);

                writer.Write(indentation);
                writer.Write("    private InputPropertyInfo ");
                writer.Write(fieldName);
                writer.WriteLine(";");
            }

            writer.WriteLine();

            var useCompatibleSyntax = _configuration.CSharpVersion == CSharpVersion.Compatible;

            foreach (var kvp in fieldNameMembers)
                GenerateDataProperty(
                    type,
                    kvp.Value,
                    false,
                    false,
                    null,
                    true,
                    (t, _) =>
                    {
                        writer.WriteLine();
                        writer.Write(indentation);
                        writer.WriteLine("    {");
                        writer.Write(indentation);
                        writer.Write("        get");
                        writer.Write(useCompatibleSyntax ? " { return " : " => ");
                        writer.Write("(");
                        writer.Write(t.NetTypeName);
                        writer.Write(")");
                        writer.Write(kvp.Key);
                        writer.Write(".Value;");

                        if (useCompatibleSyntax)
                            writer.Write(" }");

                        writer.WriteLine();

                        writer.Write(indentation);
                        writer.Write("        set");
                        writer.Write(useCompatibleSyntax ? " { " : " => ");
                        writer.Write(kvp.Key);
                        writer.Write(" = new InputPropertyInfo { Name = \"");
                        writer.Write(kvp.Value.Name);
                        writer.Write("\", Value = value");

                        if (!String.IsNullOrEmpty(t.FormatMask))
                        {
                            writer.Write(", FormatMask = \"");
                            writer.Write(t.FormatMask.Replace("\"", "\\\""));
                            writer.Write("\"");
                        }

                        writer.Write(" };");

                        if (useCompatibleSyntax)
                            writer.Write(" }");

                        writer.WriteLine();
                        writer.Write(indentation);
                        writer.WriteLine("    }");
                    },
                    context);

            writer.Write(indentation);
            writer.WriteLine("    IEnumerable<InputPropertyInfo> IGraphQlInputObject.GetPropertyValues()");
            writer.Write(indentation);
            writer.WriteLine("    {");

            foreach (var fieldName in fieldNameMembers.Keys)
            {
                writer.Write(indentation);
                writer.Write("        if (");
                writer.Write(fieldName);
                writer.Write(".Name != null) yield return ");
                writer.Write(fieldName);
                writer.WriteLine(";");
            }

            writer.Write(indentation);
            writer.WriteLine("    }");
        }

        private string GenerateInterface(GenerationContext context, string interfaceName, GraphQlType graphQlType, Action generateInterfaceBody) =>
            GenerateFileMember(context, "interface", interfaceName, graphQlType, null, generateInterfaceBody);

        private string GenerateDataClass(GenerationContext context, string typeName, GraphQlType graphQlType, string baseTypeName, Action generateClassBody) =>
            GenerateFileMember(context, "class", typeName, graphQlType, baseTypeName, generateClassBody);

        private string GenerateFileMember(GenerationContext context, string memberType, string typeName, GraphQlType graphQlType, string baseTypeName, Action generateFileMemberBody)
        {
            typeName = _configuration.ClassPrefix + typeName + _configuration.ClassSuffix;

            if (memberType == "interface")
                typeName = "I" + typeName;

            ValidateClassName(typeName);

            context.BeforeDataClassGeneration(typeName);

            var writer = context.Writer;

            GenerateCodeComments(writer, graphQlType.Description, context.Indentation);

            var indentation = GetIndentation(context.Indentation);

            if (graphQlType.Interfaces?.Count > 0)
            {
                writer.Write(indentation);
                writer.Write("[GraphQlObjectType(\"");
                writer.Write(graphQlType.Name);
                writer.WriteLine("\")]");
            }
            
            writer.Write(indentation);
            writer.Write(GetMemberAccessibility());
            writer.Write(" ");

            if (_configuration.GeneratePartialClasses)
                writer.Write("partial ");

            writer.Write(memberType);
            writer.Write(" ");
            writer.Write(typeName);

            if (!String.IsNullOrEmpty(baseTypeName))
            {
                writer.Write(" : ");
                writer.Write(baseTypeName);
            }

            writer.WriteLine();
            writer.Write(indentation);
            writer.WriteLine("{");

            generateFileMemberBody();

            writer.Write(indentation);
            writer.WriteLine("}");

            context.AfterDataClassGeneration(typeName);

            return typeName;
        }

        private static IEnumerable<GraphQlField> GetFragments(GraphQlType type, IDictionary<string, GraphQlType> complexTypeDictionary)
        {
            var fragments = new List<GraphQlField>();
            if (type.Kind != GraphQlTypeKind.Union && type.Kind != GraphQlTypeKind.Interface)
                return fragments;

            foreach (var possibleType in type.PossibleTypes)
                if (complexTypeDictionary.TryGetValue(possibleType.Name, out var consistOfType) && consistOfType.Fields != null)
                    fragments.Add(
                        new GraphQlField
                        {
                            Name = consistOfType.Name,
                            Description = consistOfType.Description,
                            Type =
                                new GraphQlFieldType
                                {
                                    Name = consistOfType.Name,
                                    Kind = consistOfType.Kind
                                }
                        });

            return fragments;
        }

        private List<GraphQlField> GetFieldsToGenerate(GraphQlType type, IDictionary<string, GraphQlType> complexTypeDictionary)
        {
            var typeFields = type.Fields;
            if (type.Kind == GraphQlTypeKind.Union)
            {
                var unionFields = new List<GraphQlField>();
                var unionFieldNames = new HashSet<string>();
                foreach (var possibleType in type.PossibleTypes)
                    if (complexTypeDictionary.TryGetValue(possibleType.Name, out var consistOfType) && consistOfType.Fields != null)
                        unionFields.AddRange(consistOfType.Fields.Where(f => unionFieldNames.Add(f.Name)));

                typeFields = unionFields;
            }

            return typeFields?.Where(FilterDeprecatedFields).ToList();
        }

        private string AddQuestionMarkIfNullableReferencesEnabled(string dataTypeIdentifier) => AddQuestionMarkIfNullableReferencesEnabled(_configuration, dataTypeIdentifier);

        internal static string AddQuestionMarkIfNullableReferencesEnabled(GraphQlGeneratorConfiguration configuration, string dataTypeIdentifier) =>
            configuration.CSharpVersion == CSharpVersion.NewestWithNullableReferences ? dataTypeIdentifier + "?" : dataTypeIdentifier;

        private bool UseCustomClassNameIfDefined(ref string typeName)
        {
            if (!_configuration.CustomClassNameMapping.TryGetValue(typeName, out var customTypeName))
                return false;

            ValidateClassName(customTypeName);
            typeName = customTypeName;
            return true;
        }

        private string GetMemberAccessibility() =>
            _configuration.MemberAccessibility == MemberAccessibility.Internal ? "internal" : "public";

        internal bool FilterDeprecatedFields(GraphQlField field) =>
            !field.IsDeprecated || _configuration.IncludeDeprecatedFields;

        private void GenerateDataProperty(
            GraphQlType baseType,
            IGraphQlMember member,
            bool isInterfaceMember,
            bool isDeprecated,
            string deprecationReason,
            bool decorateWithJsonPropertyAttribute,
            WriteDataClassPropertyBodyDelegate writeBody,
            GenerationContext context)
        {
            var propertyName = NamingHelper.ToPascalCase(member.Name);
            var propertyTypeDescription = GetDataPropertyType(baseType, member);
            var propertyTypeName = propertyTypeDescription.NetTypeName;

            var writer = context.Writer;

            GenerateCodeComments(writer, member.Description, context.Indentation + 4);

            var indentation = GetIndentation(context.Indentation);

            if (isDeprecated)
            {
                deprecationReason = String.IsNullOrWhiteSpace(deprecationReason) ? null : $"(@\"{deprecationReason.Replace("\"", "\"\"")}\")";
                writer.Write(indentation);
                writer.WriteLine($"    [Obsolete{deprecationReason}]");
            }

            if (decorateWithJsonPropertyAttribute)
            {
                decorateWithJsonPropertyAttribute =
                    _configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.Always ||
                    !String.Equals(
                        member.Name,
                        propertyName.TrimStart('@'),
                        _configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.CaseInsensitive ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);

                if (_configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.Never || _configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.UseDefaultAlias)
                    decorateWithJsonPropertyAttribute = false;
            }

            var fieldType = member.Type.UnwrapIfNonNull();
            var isGraphQlInterfaceJsonConverterRequired = fieldType.Kind == GraphQlTypeKind.Interface || fieldType.Kind == GraphQlTypeKind.List && UnwrapListItemType(fieldType, out _).UnwrapIfNonNull().Kind == GraphQlTypeKind.Interface;
            var isBaseTypeInputObject = baseType.Kind == GraphQlTypeKind.InputObject;
            var isPreprocessorDirectiveDisableNewtonsoftJsonRequired = !isInterfaceMember && decorateWithJsonPropertyAttribute || isGraphQlInterfaceJsonConverterRequired || isBaseTypeInputObject;
            if (isPreprocessorDirectiveDisableNewtonsoftJsonRequired)
            {
                writer.Write(indentation);
                writer.Write("    #if !");
                writer.WriteLine(PreprocessorDirectiveDisableNewtonsoftJson);
            }

            if (!isInterfaceMember && decorateWithJsonPropertyAttribute)
            {
                writer.Write(indentation);
                writer.WriteLine($"    [JsonProperty(\"{member.Name}\")]");
            }

            if (isGraphQlInterfaceJsonConverterRequired)
            {
                writer.Write(indentation);
                writer.WriteLine("    [JsonConverter(typeof(GraphQlInterfaceJsonConverter))]");
            }
            else if (isBaseTypeInputObject)
            {
                writer.Write(indentation);
                writer.WriteLine($"    [JsonConverter(typeof(QueryBuilderParameterConverter<{propertyTypeName}>))]");
                propertyTypeName = AddQuestionMarkIfNullableReferencesEnabled($"QueryBuilderParameter<{propertyTypeName}>");
            }

            if (isPreprocessorDirectiveDisableNewtonsoftJsonRequired)
            {
                writer.Write(indentation);
                writer.WriteLine("    #endif");
            }

            writer.Write(indentation);
            writer.Write("    ");

            if (!isInterfaceMember)
                writer.Write("public ");

            writer.Write(propertyTypeName);
            writer.Write(" ");
            writer.Write(propertyName);

            writeBody(new ScalarFieldTypeDescription { NetTypeName = propertyTypeName, FormatMask = propertyTypeDescription.FormatMask }, GetBackingFieldName(member.Name));

            writer.WriteLine();
        }

        private ScalarFieldTypeDescription GetDataPropertyType(GraphQlType baseType, IGraphQlMember member)
        {
            var fieldType = member.Type.UnwrapIfNonNull();

            switch (fieldType.Kind)
            {
                case GraphQlTypeKind.Object:
                case GraphQlTypeKind.Interface:
                case GraphQlTypeKind.Union:
                case GraphQlTypeKind.InputObject:
                    var fieldTypeName = fieldType.Name;
                    if (!UseCustomClassNameIfDefined(ref fieldTypeName))
                        fieldTypeName = NamingHelper.ToPascalCase(fieldTypeName);

                    var propertyType = _configuration.ClassPrefix + fieldTypeName + _configuration.ClassSuffix;
                    if (fieldType.Kind == GraphQlTypeKind.Interface)
                        propertyType = "I" + propertyType;

                    return ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled(propertyType));

                case GraphQlTypeKind.Enum:
                    return _configuration.ScalarFieldTypeMappingProvider.GetCustomScalarFieldType(_configuration, baseType, member.Type, member.Name);

                case GraphQlTypeKind.List:
                    var itemType = UnwrapListItemType(fieldType, out var netCollectionOpenType);
                    var unwrappedItemType = itemType?.UnwrapIfNonNull();
                    if (unwrappedItemType == null)
                        throw ListItemTypeResolutionFailedException(baseType.Name, fieldType.Name);

                    var itemTypeName = unwrappedItemType.Name;
                    if (!UseCustomClassNameIfDefined(ref itemTypeName))
                        itemTypeName = NamingHelper.ToPascalCase(itemTypeName);

                    var netItemType =
                        IsUnknownObjectScalar(baseType, member.Name, itemType)
                            ? "object"
                            : (unwrappedItemType.Kind == GraphQlTypeKind.Interface ? "I" : null) + _configuration.ClassPrefix + itemTypeName + _configuration.ClassSuffix;

                    var suggestedScalarNetType = ScalarToNetType(baseType, member.Name, itemType).NetTypeName.TrimEnd('?');
                    if (!String.Equals(suggestedScalarNetType, "object") && !String.Equals(suggestedScalarNetType, "object?") &&
                        !suggestedScalarNetType.TrimEnd().EndsWith("System.Object") && !suggestedScalarNetType.TrimEnd().EndsWith("System.Object?"))
                        netItemType = suggestedScalarNetType;

                    if (itemType.Kind != GraphQlTypeKind.NonNull)
                        netItemType = AddQuestionMarkIfNullableReferencesEnabled(netItemType);

                    var netCollectionType = String.Format(netCollectionOpenType, netItemType);
                    return ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled(netCollectionType));

                case GraphQlTypeKind.Scalar:
                    return GetScalarNetType(fieldType.Name, baseType, member);

                default:
                    return ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled("string"));
            }
        }

        private ScalarFieldTypeDescription GetScalarNetType(string scalarTypeName, GraphQlType baseType, IGraphQlMember member) =>
            scalarTypeName
                switch
                {
                    GraphQlTypeBase.GraphQlTypeScalarInteger => GetIntegerNetType(baseType, member.Type, member.Name),
                    GraphQlTypeBase.GraphQlTypeScalarString => GetCustomScalarNetType(baseType, member.Type, member.Name),
                    GraphQlTypeBase.GraphQlTypeScalarFloat => GetFloatNetType(baseType, member.Type, member.Name),
                    GraphQlTypeBase.GraphQlTypeScalarBoolean => ConvertToTypeDescription(GetBooleanNetType(baseType, member.Type, member.Name)),
                    GraphQlTypeBase.GraphQlTypeScalarId => GetIdNetType(baseType, member.Type, member.Name),
                    _ => GetCustomScalarNetType(baseType, member.Type, member.Name)
                };

        private string GetBooleanNetType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName) =>
            _configuration.BooleanTypeMapping switch
            {
                BooleanTypeMapping.Boolean => "bool?",
                BooleanTypeMapping.Custom => _configuration.ScalarFieldTypeMappingProvider.GetCustomScalarFieldType(_configuration, baseType, valueType, valueName).NetTypeName,
                _ => throw new InvalidOperationException($"'{_configuration.BooleanTypeMapping}' not supported")
            };

        private ScalarFieldTypeDescription GetFloatNetType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName) =>
            _configuration.FloatTypeMapping switch
            {
                FloatTypeMapping.Decimal => ConvertToTypeDescription("decimal?"),
                FloatTypeMapping.Float => ConvertToTypeDescription("float?"),
                FloatTypeMapping.Double => ConvertToTypeDescription("double?"),
                FloatTypeMapping.Custom => _configuration.ScalarFieldTypeMappingProvider.GetCustomScalarFieldType(_configuration, baseType, valueType, valueName),
                _ => throw new InvalidOperationException($"'{_configuration.FloatTypeMapping}' not supported")
            };

        private ScalarFieldTypeDescription GetIntegerNetType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName) =>
            _configuration.IntegerTypeMapping switch
            {
                IntegerTypeMapping.Int32 => ConvertToTypeDescription("int?"),
                IntegerTypeMapping.Int16 => ConvertToTypeDescription("short?"),
                IntegerTypeMapping.Int64 => ConvertToTypeDescription("long?"),
                IntegerTypeMapping.Custom => _configuration.ScalarFieldTypeMappingProvider.GetCustomScalarFieldType(_configuration, baseType, valueType, valueName),
                _ => throw new InvalidOperationException($"'{_configuration.IntegerTypeMapping}' not supported")
            };

        private ScalarFieldTypeDescription GetIdNetType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName) =>
            _configuration.IdTypeMapping switch
            {
                IdTypeMapping.String => ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled("string")),
                IdTypeMapping.Guid => ConvertToTypeDescription("Guid?"),
                IdTypeMapping.Object => ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled("object")),
                IdTypeMapping.Custom => _configuration.ScalarFieldTypeMappingProvider.GetCustomScalarFieldType(_configuration, baseType, valueType, valueName),
                _ => throw new InvalidOperationException($"'{_configuration.IdTypeMapping}' not supported")
            };

        private static InvalidOperationException ListItemTypeResolutionFailedException(string typeName, string fieldName) =>
            FieldTypeResolutionFailedException(typeName, fieldName, "list item type was not resolved; nested collections too deep");

        private static InvalidOperationException FieldTypeResolutionFailedException(string typeName, string fieldName, string reason) =>
            new($"field type resolution failed - type: {typeName}; field: {fieldName}{(reason == null ? null : "; reason: " + reason)}");

        private void GenerateQueryBuilder(GenerationContext context, GraphQlType type, IDictionary<string, GraphQlType> complexTypeDictionary)
        {
            var schema = context.Schema;
            var typeName = type.Name;
            if (!UseCustomClassNameIfDefined(ref typeName))
                typeName = NamingHelper.ToPascalCase(typeName);

            var className = _configuration.ClassPrefix + typeName + "QueryBuilder" + _configuration.ClassSuffix;
            ValidateClassName(className);

            context.BeforeQueryBuilderGeneration(className);

            var writer = context.Writer;
            var indentation = GetIndentation(context.Indentation);
            writer.Write(indentation);
            writer.Write(GetMemberAccessibility());
            writer.Write(" ");

            if (_configuration.GeneratePartialClasses)
                writer.Write("partial ");

            writer.Write("class ");
            writer.Write(className);
            writer.WriteLine($" : GraphQlQueryBuilder<{className}>");
            writer.Write(indentation);
            writer.WriteLine("{");
            writer.Write(indentation);
            writer.Write("    private static readonly FieldMetadata[] AllFieldMetadata =");

            var fields = type.Kind == GraphQlTypeKind.Union ? null : GetFieldsToGenerate(type, complexTypeDictionary);
            if (fields == null)
            {
                writer.WriteLine(" new FieldMetadata[0];");
                writer.WriteLine();
            }
            else
            {
                writer.WriteLine();

                var fieldMetadataIndentation = indentation;

                if (_configuration.CSharpVersion == CSharpVersion.Compatible)
                {
                    writer.Write(indentation);
                    writer.WriteLine("        new []");
                    fieldMetadataIndentation = indentation + "    ";
                }

                writer.Write(fieldMetadataIndentation);
                writer.WriteLine("    {");

                for (var i = 0; i < fields.Count; i++)
                {
                    var comma = i == fields.Count - 1 ? null : ",";
                    var field = fields[i];
                    var fieldType = field.Type.UnwrapIfNonNull();
                    var isList = fieldType.Kind == GraphQlTypeKind.List;
                    var treatUnknownObjectAsComplex = IsUnknownObjectScalar(type, field.Name, fieldType) && !_configuration.TreatUnknownObjectAsScalar;
                    var isComplex = isList || treatUnknownObjectAsComplex || IsComplexType(fieldType.Kind);

                    writer.Write(fieldMetadataIndentation);
                    writer.Write("        new FieldMetadata { Name = \"");
                    writer.Write(field.Name);
                    writer.Write('"');

                    var csharpPropertyName = NamingHelper.ToPascalCase(field.Name);
                    if (_configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.UseDefaultAlias && !String.Equals(field.Name, csharpPropertyName, StringComparison.OrdinalIgnoreCase))
                    {
                        writer.Write(", DefaultAlias = \"");
                        writer.Write(NamingHelper.LowerFirst(csharpPropertyName));
                        writer.Write('"');
                    }

                    if (isComplex)
                    {
                        writer.Write(", IsComplex = true");

                        if (isList)
                        {
                            var itemType = UnwrapListItemType(fieldType, out _)?.UnwrapIfNonNull();
                            fieldType = itemType ?? throw ListItemTypeResolutionFailedException(type.Name, field.Name);
                        }

                        if (fieldType.Kind != GraphQlTypeKind.Scalar && fieldType.Kind != GraphQlTypeKind.Enum && fieldType.Kind != GraphQlTypeKind.List)
                        {
                            var fieldTypeName = fieldType.Name;
                            if (fieldTypeName == null)
                                throw FieldTypeResolutionFailedException(type.Name, field.Name, null);

                            if (!UseCustomClassNameIfDefined(ref fieldTypeName))
                                fieldTypeName = NamingHelper.ToPascalCase(fieldTypeName);
                            
                            writer.Write($", QueryBuilderType = typeof({_configuration.ClassPrefix}{fieldTypeName}QueryBuilder{_configuration.ClassSuffix})");
                        }
                    }

                    writer.WriteLine($" }}{comma}");
                }

                writer.Write(fieldMetadataIndentation);
                writer.WriteLine("    };");
                writer.WriteLine();
            }

            GraphQlDirectiveLocation directiveLocation;
            if (type.Name == schema.QueryType?.Name)
                directiveLocation = GraphQlDirectiveLocation.Query;
            else if (type.Name == schema.MutationType?.Name)
                directiveLocation = GraphQlDirectiveLocation.Mutation;
            else if (type.Name == schema.SubscriptionType?.Name)
                directiveLocation = GraphQlDirectiveLocation.Subscription;
            else
                directiveLocation = GraphQlDirectiveLocation.Field;

            var hasQueryPrefix = directiveLocation != GraphQlDirectiveLocation.Field;

            WriteOverrideProperty("protected", "string", "TypeName", $"\"{type.Name}\"", indentation, writer);

            WriteOverrideProperty("public", "IReadOnlyList<FieldMetadata>", "AllFields", "AllFieldMetadata", indentation, writer);

            string ReturnPrefix(bool requiresFullBody) => requiresFullBody ? indentation + "        return " : String.Empty;

            var useCompatibleSyntax = _configuration.CSharpVersion == CSharpVersion.Compatible;
            var stringDataType = AddQuestionMarkIfNullableReferencesEnabled("string");

            if (hasQueryPrefix)
            {
                writer.Write(indentation);
                writer.Write("    public ");
                writer.Write(className);
                writer.Write("(");
                writer.Write(stringDataType);
                writer.Write(" operationName = null) : base(\"");
                writer.Write(directiveLocation.ToString().ToLowerInvariant());
                writer.WriteLine("\", operationName)");
                writer.Write(indentation);
                writer.WriteLine("    {");
                writer.Write(indentation);
                writer.WriteLine("    }");
                writer.WriteLine();

                writer.Write(indentation);
                writer.Write($"    public {className} WithParameter<T>(GraphQlQueryParameter<T> parameter)");
                WriteQueryBuilderMethodBody(
                    useCompatibleSyntax,
                    indentation,
                    writer,
                    () => writer.WriteLine($"{ReturnPrefix(useCompatibleSyntax)}WithParameterInternal(parameter);"));

                writer.WriteLine();
            }

            var fragments = GetFragments(type, complexTypeDictionary);
            fields ??= new List<GraphQlField>();
            var firstFragmentIndex = fields.Count;
            fields.AddRange(fragments);

            for (var i = 0; i < fields.Count; i++)
            {
                var field = fields[i];
                var fieldType = field.Type.UnwrapIfNonNull();
                if (fieldType.Kind == GraphQlTypeKind.List)
                    fieldType = fieldType.OfType;
                
                fieldType = fieldType.UnwrapIfNonNull();
                var isFragment = i >= firstFragmentIndex;

                static bool IsCompatibleArgument(GraphQlFieldType argumentType)
                {
                    argumentType = argumentType.UnwrapIfNonNull();
                    return
                        argumentType.Kind switch
                        {
                            GraphQlTypeKind.Scalar => true,
                            GraphQlTypeKind.Enum => true,
                            GraphQlTypeKind.InputObject => true,
                            GraphQlTypeKind.List => IsCompatibleArgument(argumentType.OfType),
                            _ => false
                        };
                }

                var argumentDefinitions =
                    field.Args?.Where(a => IsCompatibleArgument(a.Type)).Select(a => BuildMethodParameterDefinition(type, a)).ToArray()
                    ?? new QueryBuilderParameterDefinition[0];

                var methodParameters =
                    String.Join(
                        ", ",
                        argumentDefinitions
                            .OrderByDescending(d => d.Argument.Type.Kind == GraphQlTypeKind.NonNull)
                            .Select(d => d.NetParameterDefinitionClause));

                var requiresFullBody = useCompatibleSyntax || argumentDefinitions.Any();
                var returnPrefix = ReturnPrefix(requiresFullBody);
                var csharpPropertyName = NamingHelper.ToPascalCase(field.Name);

                void WriteAliasParameter()
                {
                    writer.Write(stringDataType);
                    writer.Write(" alias = ");

                    if (_configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.UseDefaultAlias && !String.Equals(field.Name, csharpPropertyName, StringComparison.OrdinalIgnoreCase))
                    {
                        writer.Write('"');
                        writer.Write(NamingHelper.LowerFirst(csharpPropertyName));
                        writer.Write('"');
                    }
                    else
                        writer.Write("null");
                }

                if (fieldType.Kind == GraphQlTypeKind.Scalar || fieldType.Kind == GraphQlTypeKind.Enum || fieldType.Kind == GraphQlTypeKind.List)
                {
                    writer.Write(indentation);
                    writer.Write("    public ");
                    writer.Write(className);
                    writer.Write(" With");
                    writer.Write(csharpPropertyName);
                    writer.Write("(");
                    writer.Write(methodParameters);

                    if (!String.IsNullOrEmpty(methodParameters))
                        writer.Write(", ");

                    WriteAliasParameter();
                    
                    var fieldDirectiveParameterNameList = WriteDirectiveParameterList(schema, argumentDefinitions, GraphQlDirectiveLocation.Field, writer);
                    
                    writer.Write(")");

                    WriteQueryBuilderMethodBody(
                        requiresFullBody,
                        indentation,
                        writer,
                        () =>
                        {
                            AppendArgumentDictionary(indentation, writer, argumentDefinitions);

                            writer.Write(returnPrefix);
                            writer.Write("WithScalarField(\"");
                            writer.Write(field.Name);
                            writer.Write("\", alias, ");
                            writer.Write(fieldDirectiveParameterNameList);

                            if (argumentDefinitions.Length > 0)
                                writer.Write(", args");

                            writer.WriteLine(");");
                        });
                }
                else
                {
                    var fieldTypeName = fieldType.Name;
                    if (String.IsNullOrEmpty(fieldTypeName))
                        throw FieldTypeResolutionFailedException(type.Name, field.Name, null);

                    if (!UseCustomClassNameIfDefined(ref fieldTypeName))
                        fieldTypeName = NamingHelper.ToPascalCase(fieldTypeName);

                    var builderParameterName = NamingHelper.LowerFirst(fieldTypeName);
                    writer.Write(indentation);
                    writer.Write($"    public {className} With{csharpPropertyName}{(isFragment ? "Fragment" : null)}({_configuration.ClassPrefix}{fieldTypeName}QueryBuilder{_configuration.ClassSuffix} {builderParameterName}QueryBuilder");

                    if (argumentDefinitions.Length > 0)
                    {
                        writer.Write(", ");
                        writer.Write(methodParameters);
                    }

                    if (!isFragment)
                    {
                        writer.Write(", ");
                        WriteAliasParameter();
                    }

                    var fieldDirectiveParameterNameList = WriteDirectiveParameterList(schema, argumentDefinitions, GraphQlDirectiveLocation.Field, writer);

                    writer.Write(")");

                    WriteQueryBuilderMethodBody(
                        requiresFullBody,
                        indentation,
                        writer,
                        () =>
                        {
                            AppendArgumentDictionary(indentation, writer, argumentDefinitions);

                            writer.Write(returnPrefix);
                            writer.Write("With");

                            if (isFragment)
                                writer.Write("Fragment(");
                            else
                            {
                                writer.Write("ObjectField(\"");
                                writer.Write(field.Name);
                                writer.Write("\", alias, ");
                            }

                            writer.Write(builderParameterName);
                            writer.Write("QueryBuilder");

                            writer.Write(", ");
                            writer.Write(fieldDirectiveParameterNameList);

                            if (argumentDefinitions.Length > 0)
                                writer.Write(", args");

                            writer.WriteLine(");");
                        });
                }

                if (!isFragment)
                {
                    writer.WriteLine();

                    writer.Write(indentation);
                    writer.Write($"    public {className} Except{csharpPropertyName}()");

                    WriteQueryBuilderMethodBody(
                        useCompatibleSyntax,
                        indentation,
                        writer,
                        () => writer.WriteLine($"{ReturnPrefix(useCompatibleSyntax)}ExceptField(\"{field.Name}\");"));
                }

                if (i < fields.Count - 1)
                    writer.WriteLine();
            }

            writer.Write(indentation);
            writer.WriteLine("}");

            context.AfterQueryBuilderGeneration(className);
        }

        private GraphQlFieldType UnwrapListItemType(GraphQlFieldType type, out string netCollectionOpenType)
        {
            var levels = 0;

            var nullableSymbols = new List<string> { String.Empty };

            while (true)
            {
                levels++;

                var unwrappedType = type.OfType?.UnwrapIfNonNull();
                if (unwrappedType == null)
                {
                    netCollectionOpenType = null;
                    return null;
                }

                if (unwrappedType.Kind != GraphQlTypeKind.List)
                {
                    type = type.OfType;
                    break;
                }

                nullableSymbols.Add(type.OfType.Kind == GraphQlTypeKind.NonNull ? String.Empty : AddQuestionMarkIfNullableReferencesEnabled(String.Empty));
                type = unwrappedType;
            }

            nullableSymbols.Reverse();

            netCollectionOpenType =
                levels == 1
                    ? "ICollection<{0}>"
                    : String.Concat(Enumerable.Repeat("IList<", levels).Concat(new[] { "{0}" }).Concat(nullableSymbols.Select(s => ">" + s)));

            return type;
        }

        private string WriteDirectiveParameterList(GraphQlSchema schema, IEnumerable<QueryBuilderParameterDefinition> argumentDefinitions, GraphQlDirectiveLocation directiveLocation, TextWriter writer)
        {
            var argumentNames = new HashSet<string>(argumentDefinitions.Select(ad => ad.NetParameterName));
            var directiveParameterNames = new List<string>();

            foreach (var directive in schema.Directives.Where(d => d.Locations.Contains(directiveLocation)))
            {
                var csharpDirectiveName = NamingHelper.ToPascalCase(directive.Name);
                var directiveClassName = csharpDirectiveName + "Directive";
                var directiveParameterName = NamingHelper.LowerFirst(csharpDirectiveName);

                if (argumentNames.Contains(directiveParameterName))
                {
                    directiveParameterName += "Directive";

                    if (argumentNames.Contains(directiveParameterName))
                    {
                        directiveParameterName += "Value";

                        var parameterCounter = 0;
                        var directiveParameterNameWithCounter = directiveParameterName;
                        while (argumentNames.Contains(directiveParameterNameWithCounter))
                            directiveParameterNameWithCounter = directiveParameterName + ++parameterCounter;

                        directiveParameterName = directiveParameterNameWithCounter;
                    }
                }

                directiveParameterNames.Add(directiveParameterName);

                writer.Write(", ");
                writer.Write(AddQuestionMarkIfNullableReferencesEnabled(directiveClassName));
                writer.Write(" ");
                writer.Write(directiveParameterName);
                writer.Write(" = null");
            }

            return
                directiveParameterNames.Any()
                    ? "new " + AddQuestionMarkIfNullableReferencesEnabled("GraphQlDirective") + "[] { " + String.Join(", ", directiveParameterNames) + " }"
                    : "null";
        }

        private static void WriteQueryBuilderMethodBody(bool requiresFullBody, string indentation, TextWriter writer, Action writeBody)
        {
            if (requiresFullBody)
            {
                writer.WriteLine();
                writer.Write(indentation);
                writer.WriteLine("    {");
            }
            else
                writer.Write(" => ");

            writeBody();

            if (requiresFullBody)
            {
                writer.Write(indentation);
                writer.WriteLine("    }");
            }
        }

        private void WriteOverrideProperty(string accessibility, string propertyType, string propertyName, string propertyValue, string indentation, TextWriter writer)
        {
            writer.Write(indentation);
            writer.Write("    ");
            writer.Write(accessibility);
            writer.Write(" override ");
            writer.Write(propertyType);
            writer.Write(" ");
            writer.Write(propertyName);
            writer.Write(" { get");

            if (_configuration.CSharpVersion == CSharpVersion.Compatible)
            {
                writer.Write(" { return ");
                writer.Write(propertyValue);
                writer.WriteLine("; } } ");
            }
            else
            {
                writer.Write("; } = ");
                writer.Write(propertyValue);
                writer.WriteLine(";");
            }

            writer.WriteLine();
        }

        private QueryBuilderParameterDefinition BuildMethodParameterDefinition(GraphQlType baseType, GraphQlArgument argument)
        {
            var argumentType = argument.Type;
            var isArgumentNotNull = argumentType.Kind == GraphQlTypeKind.NonNull;
            var isTypeNotNull = isArgumentNotNull;
            var unwrappedType = argumentType.UnwrapIfNonNull();
            var isCollection = unwrappedType.Kind == GraphQlTypeKind.List;
            if (isCollection)
            {
                isTypeNotNull = unwrappedType.OfType.Kind == GraphQlTypeKind.NonNull;
                argumentType = unwrappedType.OfType;
                unwrappedType = argumentType.UnwrapIfNonNull();
            }

            var argumentTypeDescription =
                unwrappedType.Kind == GraphQlTypeKind.Enum
                    ? ConvertToTypeDescription(_configuration.ClassPrefix + NamingHelper.ToPascalCase(unwrappedType.Name) + _configuration.ClassSuffix + "?")
                    : ScalarToNetType(baseType, argument.Name, argumentType);
            
            var argumentNetType = argumentTypeDescription.NetTypeName;
            
            if (isTypeNotNull)
                argumentNetType = argumentNetType.TrimEnd('?');

            var isInputObject = unwrappedType.Kind == GraphQlTypeKind.InputObject;
            if (isInputObject)
            {
                argumentNetType = unwrappedType.Name;

                if (!UseCustomClassNameIfDefined(ref argumentNetType))
                    argumentNetType = NamingHelper.ToPascalCase(argumentNetType);

                argumentNetType = _configuration.ClassPrefix + argumentNetType + _configuration.ClassSuffix;
                
                if (!isTypeNotNull)
                    argumentNetType = AddQuestionMarkIfNullableReferencesEnabled(argumentNetType);
            }

            argumentNetType = isCollection ? $"QueryBuilderParameter<IEnumerable<{argumentNetType}>>" : $"QueryBuilderParameter<{argumentNetType}>";

            if (!isArgumentNotNull)
                argumentNetType = AddQuestionMarkIfNullableReferencesEnabled(argumentNetType);

            var netParameterName = NamingHelper.ToValidCSharpName(NamingHelper.LowerFirst(NamingHelper.ToPascalCase(argument.Name)));
            var argumentDefinition = $"{argumentNetType} {netParameterName}";
            if (!isArgumentNotNull)
                argumentDefinition += " = null";

            return
                new QueryBuilderParameterDefinition
                {
                    Argument = argument,
                    NetParameterName = netParameterName,
                    NetParameterDefinitionClause = argumentDefinition,
                    FormatMask = argumentTypeDescription.FormatMask
                };
        }

        private static void ValidateClassName(string className)
        {
            if (!CSharpHelper.IsValidIdentifier(className))
                throw new InvalidOperationException($"Resulting class name '{className}' is not valid. ");
        }

        private static void AppendArgumentDictionary(string indentation, TextWriter writer, ICollection<QueryBuilderParameterDefinition> argumentDefinitions)
        {
            if (argumentDefinitions.Count == 0)
                return;

            writer.Write(indentation);
            writer.WriteLine("        var args = new List<QueryBuilderArgumentInfo>();");

            static void WriteAddKeyValuePair(TextWriter writer, QueryBuilderParameterDefinition argumentDefinition)
            {
                var argument = argumentDefinition.Argument;
                writer.Write("args.Add(new QueryBuilderArgumentInfo { ArgumentName = \"");
                writer.Write(argument.Name);
                writer.Write("\", ArgumentValue = ");
                writer.Write(argumentDefinition.NetParameterName);

                if (!String.IsNullOrEmpty(argumentDefinition.FormatMask))
                {
                    writer.Write(", FormatMask = \"");
                    writer.Write(argumentDefinition.FormatMask.Replace("\"", "\\\""));
                    writer.Write("\"");
                }

                writer.WriteLine("} );");
            }

            foreach (var argumentDefinition in argumentDefinitions)
            {
                writer.Write(indentation);

                if (argumentDefinition.Argument.Type.Kind == GraphQlTypeKind.NonNull)
                {
                    writer.Write("        ");
                    WriteAddKeyValuePair(writer, argumentDefinition);
                }
                else
                {
                    writer.Write("        if (");
                    writer.Write(argumentDefinition.NetParameterName);
                    writer.WriteLine(" != null)");
                    writer.Write(indentation);
                    writer.Write("            ");
                    WriteAddKeyValuePair(writer, argumentDefinition);
                    writer.WriteLine();
                }
            }
        }

        private void GenerateEnum(GenerationContext context, GraphQlType type)
        {
            var enumName = _configuration.ClassPrefix + NamingHelper.ToPascalCase(type.Name) + _configuration.ClassSuffix;
            
            context.BeforeEnumGeneration(enumName);
            
            var writer = context.Writer;

            GenerateCodeComments(writer, type.Description, context.Indentation);
            var indentation = GetIndentation(context.Indentation);
            writer.Write(indentation);
            writer.Write("public enum ");
            writer.WriteLine(enumName);
            writer.Write(indentation);
            writer.WriteLine("{");

            var enumValues = type.EnumValues.ToList();
            for (var i = 0; i < enumValues.Count; i++)
            {
                var enumValue = enumValues[i];
                GenerateCodeComments(writer, enumValue.Description, context.Indentation + 4);
                writer.Write(indentation);
                writer.Write("    ");
                var netIdentifier = NamingHelper.ToCSharpEnumName(enumValue.Name);
                if (netIdentifier != enumValue.Name)
                    writer.Write($"[EnumMember(Value = \"{enumValue.Name}\")] ");

                writer.Write(netIdentifier);

                if (i < enumValues.Count - 1)
                    writer.Write(",");

                writer.WriteLine();
            }

            writer.Write(indentation);
            writer.WriteLine("}");

            context.AfterEnumGeneration(enumName);
        }

        private static readonly HashSet<GraphQlDirectiveLocation> SupportedDirectiveLocations =
            new()
            {
                GraphQlDirectiveLocation.Object,
                GraphQlDirectiveLocation.Field,
                GraphQlDirectiveLocation.Query,
                GraphQlDirectiveLocation.Mutation,
                GraphQlDirectiveLocation.Subscription
            };

        private void GenerateDirectives(GenerationContext context)
        {
            if (IsQueryBuilderGenerationDisabled(context.ObjectTypes))
                return;

            var queryBuilderDirectives = context.Schema.Directives.Where(t => SupportedDirectiveLocations.Overlaps(t.Locations)).ToList();
            if (!queryBuilderDirectives.Any())
                return;

            context.BeforeDirectivesGeneration();

            queryBuilderDirectives.ForEach(d => GenerateDirective(context, d));

            context.AfterDirectivesGeneration();
        }

        private void GenerateDirective(GenerationContext context, GraphQlDirective directive)
        {
            var directiveName = NamingHelper.ToPascalCase(directive.Name) + "Directive";

            context.BeforeDirectiveGeneration(directiveName);

            var writer = context.Writer;

            GenerateCodeComments(writer, directive.Description, context.Indentation);

            var orderedArgumentDefinitions = directive.Args.OrderByDescending(a => a.Type.Kind == GraphQlTypeKind.NonNull).Select(a => BuildMethodParameterDefinition(null, a)).ToArray();
            var argumentList = String.Join(", ", orderedArgumentDefinitions.Select(d => d.NetParameterDefinitionClause));

            var indentation = GetIndentation(context.Indentation);
            writer.Write(indentation);
            writer.Write("public class ");
            writer.Write(directiveName);
            writer.WriteLine(" : GraphQlDirective");
            writer.Write(indentation);
            writer.WriteLine("{");
            writer.Write(indentation);
            writer.Write("    public ");
            writer.Write(directiveName);
            writer.Write("(");
            writer.Write(argumentList);
            writer.Write(") : base(\"");
            writer.Write(directive.Name);
            writer.WriteLine("\")");
            writer.Write(indentation);
            writer.WriteLine("    {");

            foreach (var definition in orderedArgumentDefinitions)
            {
                writer.Write(indentation);
                writer.Write("        AddArgument(\"");
                writer.Write(definition.Argument.Name);
                writer.Write("\", ");
                writer.Write(NamingHelper.ToValidCSharpName(definition.Argument.Name));
                writer.WriteLine(");");
            }

            writer.Write(indentation);
            writer.WriteLine("    }");
            writer.Write(indentation);
            writer.WriteLine("}");

            context.AfterDirectiveGeneration(directiveName);
        }

        private void GenerateCodeComments(TextWriter writer, string description, int indentationSize)
        {
            if (String.IsNullOrWhiteSpace(description))
                return;

            var indentation = GetIndentation(indentationSize);

            if (_configuration.CommentGeneration.HasFlag(CommentGenerationOption.CodeSummary))
            {
                writer.Write(indentation);
                writer.WriteLine("/// <summary>");
                writer.Write(indentation);
                writer.WriteLine("/// " + String.Join(Environment.NewLine + indentation + "/// ", description.Split('\n').Select(l => l.Trim())));
                writer.Write(indentation);
                writer.WriteLine("/// </summary>");
            }

            if (_configuration.CommentGeneration.HasFlag(CommentGenerationOption.DescriptionAttribute))
            {
                writer.Write(indentation);
                writer.WriteLine($"[Description(@\"{description.Replace("\"", "\"\"")}\")]");
            }
        }

        private bool IsUnknownObjectScalar(GraphQlType baseType, string valueName, GraphQlFieldType fieldType)
        {
            if (fieldType.UnwrapIfNonNull().Kind != GraphQlTypeKind.Scalar)
                return false;

            var netType = ScalarToNetType(baseType, valueName, fieldType).NetTypeName;
            return netType == "object" || netType.TrimEnd().EndsWith("System.Object") || netType == "object?" || netType.TrimEnd().EndsWith("System.Object?");
        }

        private ScalarFieldTypeDescription ScalarToNetType(GraphQlType baseType, string valueName, GraphQlFieldType valueType) =>
            valueType.UnwrapIfNonNull().Name switch
            {
                GraphQlTypeBase.GraphQlTypeScalarInteger => GetIntegerNetType(baseType, valueType, valueName),
                GraphQlTypeBase.GraphQlTypeScalarString => GetCustomScalarNetType(baseType, valueType, valueName),
                GraphQlTypeBase.GraphQlTypeScalarFloat => GetFloatNetType(baseType, valueType, valueName),
                GraphQlTypeBase.GraphQlTypeScalarBoolean => ConvertToTypeDescription(GetBooleanNetType(baseType, valueType, valueName)),
                GraphQlTypeBase.GraphQlTypeScalarId => GetIdNetType(baseType, valueType, valueName),
                _ => GetCustomScalarNetType(baseType, valueType, valueName)
            };

        private ScalarFieldTypeDescription GetCustomScalarNetType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName)
        {
            if (_configuration.ScalarFieldTypeMappingProvider == null)
                throw new InvalidOperationException($"'{nameof(_configuration.ScalarFieldTypeMappingProvider)}' missing");

            var typeDescription = _configuration.ScalarFieldTypeMappingProvider.GetCustomScalarFieldType(_configuration, baseType, valueType, valueName);
            if (String.IsNullOrWhiteSpace(typeDescription.NetTypeName))
                throw new InvalidOperationException($".NET type for '{baseType.Name}.{valueName}' ({valueType.Name}) cannot be resolved. Please check {nameof(_configuration)}.{nameof(_configuration.ScalarFieldTypeMappingProvider)} implementation. ");

            if (typeDescription.FormatMask != null && String.IsNullOrWhiteSpace(typeDescription.FormatMask))
                throw new InvalidOperationException("invalid format mask");

            return typeDescription;
        }

        private static ScalarFieldTypeDescription ConvertToTypeDescription(string netTypeName) => new() { NetTypeName = netTypeName };

        private struct QueryBuilderParameterDefinition
        {
            public GraphQlArgument Argument;
            public string NetParameterName;
            public string NetParameterDefinitionClause;
            public string FormatMask;
        }
    }
}
using System.Net.Http.Headers;
using System.Reflection;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Serialization;

namespace GraphQlClientGenerator;

public class GraphQlGenerator
{
    internal const string AutoGeneratedLabel = "// <auto-generated> This file has been auto generated. </auto-generated>";

    public const string PreprocessorDirectiveDisableNewtonsoftJson = "GRAPHQL_GENERATOR_DISABLE_NEWTONSOFT_JSON";

    public const string RequiredNamespaces =
        $@"using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
#if !{PreprocessorDirectiveDisableNewtonsoftJson}
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
#endif
";

    private delegate void WriteDataClassPropertyBodyDelegate(ScalarFieldTypeDescription netType, string backingFieldName);

    private static readonly HttpClient HttpClient =
        new()
        {
            DefaultRequestHeaders =
            {
                UserAgent = { ProductInfoHeaderValue.Parse($"GraphQlClientGenerator/{typeof(GraphQlGenerator).GetTypeInfo().Assembly.GetName().Version}") }
            }
        };

    private static readonly JsonSerializerSettings SerializerSettings =
        new()
        {
            ContractResolver = new CamelCasePropertyNamesContractResolver(),
            Converters = { new StringEnumConverter() }
        };

    private readonly GraphQlGeneratorConfiguration _configuration;

    public GraphQlGenerator(GraphQlGeneratorConfiguration configuration = null) =>
        _configuration = configuration ?? new GraphQlGeneratorConfiguration();

    public static async Task<GraphQlSchema> RetrieveSchema(HttpMethod method, string url, IEnumerable<KeyValuePair<string, string>> headers = null)
    {
        StringContent requestContent = null;
        if (method == HttpMethod.Get)
            url += $"?&query={IntrospectionQuery.Text}";
        else
            requestContent = new StringContent(JsonConvert.SerializeObject(new { query = IntrospectionQuery.Text }), Encoding.UTF8, "application/json");

        using var request = new HttpRequestMessage(method, url) { Content = requestContent };

        if (headers is not null)
            foreach (var kvp in headers)
                request.Headers.TryAddWithoutValidation(kvp.Key, kvp.Value);

        using var response = await HttpClient.SendAsync(request);

        var content =
            response.Content is null
                ? "(no content)"
                : await response.Content.ReadAsStringAsync();

        if (!response.IsSuccessStatusCode)
            throw new InvalidOperationException($"Status code: {(int)response.StatusCode} ({response.StatusCode}){Environment.NewLine}content:{Environment.NewLine}{content}");

        return DeserializeGraphQlSchema(content);
    }

    public static GraphQlSchema DeserializeGraphQlSchema(string content)
    {
        try
        {
            var schema =
                JsonConvert.DeserializeObject<GraphQlResult>(content, SerializerSettings)?.Data?.Schema
                ?? JsonConvert.DeserializeObject<GraphQlData>(content, SerializerSettings)?.Schema;

            if (schema is null)
                throw new ArgumentException("not a GraphQL schema", nameof(content));

            return schema;
        }
        catch (JsonReaderException exception)
        {
            throw new ArgumentException("not a GraphQL schema", nameof(content), exception);
        }
    }

    public string GenerateFullClientCSharpFile(GraphQlSchema schema, string @namespace)
    {
        var builder = new StringBuilder();
        using var writer = new StringWriter(builder);
        WriteFullClientCSharpFile(schema, @namespace, writer);
        return builder.ToString();
    }

    public void WriteFullClientCSharpFile(GraphQlSchema schema, string @namespace, TextWriter writer)
    {
        if (String.IsNullOrWhiteSpace(@namespace))
            throw new ArgumentException("namespace required", nameof(@namespace));

        if (!CSharpHelper.IsValidNamespace(@namespace))
            throw new ArgumentException($"invalid namespace '{@namespace}'", nameof(@namespace));

        writer.WriteLine(AutoGeneratedLabel);
        writer.WriteLine();
        writer.WriteLine(RequiredNamespaces);
        writer.Write("namespace ");

        if (_configuration.FileScopedNamespaces)
        {
            writer.Write(@namespace);
            writer.WriteLine(";");
            writer.WriteLine();
            Generate(new SingleFileGenerationContext(schema, writer, indentationSize: 0));
        }
        else
        {
            writer.WriteLine(@namespace);
            writer.WriteLine("{");
            Generate(new SingleFileGenerationContext(schema, writer, indentationSize: 4));
            writer.WriteLine("}");
        }

        writer.Flush();
    }

    public string Generate(GraphQlSchema schema)
    {
        var builder = new StringBuilder();
        using var writer = new StringWriter(builder);
        Generate(new SingleFileGenerationContext(schema, writer));
        return builder.ToString();
    }

    public void Generate(GenerationContext context)
    {
        ResolveNameCollisions(context);

        context.BeforeGeneration(_configuration);

        GenerateBaseClasses(context);

        GenerateGraphQlTypeNames(context);

        GenerateEnums(context);

        GenerateDirectives(context);

        GenerateQueryBuilders(context);

        GenerateInputObjects(context);

        GenerateDataClasses(context);

        context.AfterGeneration();
    }

    private void ResolveNameCollisions(GenerationContext context)
    {
        var complexTypes = GetComplexTypes(context.Schema);
        var complexTypeCsharpNames = new HashSet<string>(complexTypes.Keys.Select(NamingHelper.ToPascalCase));
        var inputObjectTypes = new HashSet<string>(GetInputObjectTypes(context.Schema).Select(t => NamingHelper.ToPascalCase(t.Name)));
        var objectTypes = new HashSet<string>();
        var collisionMapping = new Dictionary<string, string>();

        foreach (var graphQlType in context.Schema.Types.Where(t => !t.IsBuiltIn))
        {
            var isInputObject = graphQlType.Kind == GraphQlTypeKind.InputObject;
            var propertyNamesToGenerate = new List<string>();
            if (isInputObject)
            {
                FindAllReferencedObjectTypes(context.Schema, graphQlType, objectTypes);
                propertyNamesToGenerate.AddRange(graphQlType.InputFields.Select(f => NamingHelper.ToPascalCase(f.Name)));
            }
            else if (IsComplexType(graphQlType.Kind))
                propertyNamesToGenerate.AddRange(GetFieldsToGenerate(graphQlType, complexTypes).Select(f => NamingHelper.ToPascalCase(f.Name)));
            else
                continue;

            var candidateClassName = NamingHelper.ToPascalCase(graphQlType.Name);;
            var finalClassName = candidateClassName;
            var collisionIteration = 1;

            do
            {
                var finalClassNameIncludingPrefixAndSuffix = $"{_configuration.ClassPrefix}{finalClassName}{_configuration.ClassSuffix}";
                var hasNameCollision = propertyNamesToGenerate.Any(n => n == finalClassNameIncludingPrefixAndSuffix);
                if (candidateClassName != finalClassName)
                    hasNameCollision |= complexTypeCsharpNames.Contains(finalClassName) || inputObjectTypes.Contains(finalClassName);

                if (!hasNameCollision)
                    break;

                if (collisionIteration == 1)
                {
                    if (isInputObject && !candidateClassName.EndsWith("Input"))
                        finalClassName = $"{candidateClassName}Input";
                    if (isInputObject && !candidateClassName.EndsWith("InputObject"))
                        finalClassName = $"{candidateClassName}InputObject";
                    else if (!candidateClassName.EndsWith("Data"))
                        finalClassName = $"{candidateClassName}Data";
                    else if (!candidateClassName.EndsWith("Record"))
                        finalClassName = $"{candidateClassName}Record";
                    else if (!candidateClassName.EndsWith("Data") && !candidateClassName.EndsWith("DataRecord"))
                        finalClassName = $"{candidateClassName}DataRecord";

                    collisionIteration++;
                }
                else
                    finalClassName = $"{candidateClassName}{collisionIteration++}";
            } while (true);

            if (finalClassName != candidateClassName)
                collisionMapping.Add(graphQlType.Name, finalClassName);
        }

        context.ReferencedObjectTypes = objectTypes;
        context.NameCollisionMapping = collisionMapping;
    }

    private void GenerateGraphQlTypeNames(GenerationContext context)
    {
        context.BeforeGraphQlTypeNameGeneration();

        var indentation = GetIndentation(context.Indentation);
        var writer = context.Writer;
        writer.Write(indentation);
        writer.WriteLine("public static class GraphQlTypes");
        writer.Write(indentation);
        writer.WriteLine("{");

        var graphQlTypes = context.Schema.Types.Where(t => !t.IsBuiltIn).OrderBy(t => t.Kind).ThenBy(t => t.Name).ToArray();
        GraphQlType precedingInputObjectType = null;
        foreach (var inputObjectType in graphQlTypes)
        {
            if (precedingInputObjectType is not null && inputObjectType.Kind != precedingInputObjectType.Kind)
                writer.WriteLine();

            writer.Write(indentation);
            writer.Write("    public const string ");
            writer.Write(NamingHelper.ToPascalCase(inputObjectType.Name));
            writer.Write(" = \"");
            writer.Write(inputObjectType.Name);
            writer.WriteLine("\";");

            precedingInputObjectType = inputObjectType;
        }

        writer.WriteLine();
        writer.Write(indentation);
        writer.WriteLine("    public static readonly IReadOnlyDictionary<Type, string> ReverseMapping =");
        writer.Write(indentation);
        writer.WriteLine("        new Dictionary<Type, string>");
        writer.Write(indentation);
        writer.WriteLine("        {");

        var netTypeKeys = new HashSet<string>();
        string typeMappingSeparator = null;

        void WriteMappingEntry(string netType, string graphQlTypeName)
        {
            if (!netTypeKeys.Add(netType))
                return;

            if (typeMappingSeparator is not null)
                writer.WriteLine(typeMappingSeparator);

            writer.Write(indentation);
            writer.Write("            { typeof(");
            writer.Write(netType);
            writer.Write("), \"");
            writer.Write(graphQlTypeName);
            writer.Write("\" }");

            typeMappingSeparator = ",";
        }

        foreach (var type in graphQlTypes.Where(t => t.Kind is GraphQlTypeKind.Object or GraphQlTypeKind.InputObject))
        {
            if (type.Kind == GraphQlTypeKind.InputObject)
            {
                var netType = $"{_configuration.ClassPrefix}{GetCSharpClassName(context, type.Name)}{_configuration.ClassSuffix}";
                WriteMappingEntry(netType, type.Name);
            }
            else
            {
                foreach (var member in type.Kind == GraphQlTypeKind.Object ? (IEnumerable<IGraphQlMember>)type.Fields : type.InputFields)
                {
                    var fieldType = member.Type.UnwrapIfNonNull();
                    if (fieldType.Kind == GraphQlTypeKind.List)
                    {
                        var itemType = UnwrapListItemType(fieldType, out _);
                        fieldType = itemType?.UnwrapIfNonNull();
                        if (fieldType is null)
                            continue;
                    }

                    if (fieldType.Kind != GraphQlTypeKind.Scalar)
                        continue;

                    var netType = GetScalarNetType(fieldType.Name, type, member).NetTypeName.Trim().TrimEnd('?');
                    if (netType.EndsWith("object") || netType.EndsWith("System.Object"))
                        continue;

                    WriteMappingEntry(netType, fieldType.Name);
                }
            }
        }

        writer.WriteLine();
        writer.Write(indentation);
        writer.WriteLine("        };");
        writer.WriteLine("}");

        context.AfterGraphQlTypeNameGeneration();
    }

    private void GenerateEnums(GenerationContext context)
    {
        var enumTypes = context.Schema.Types.Where(t => t.Kind == GraphQlTypeKind.Enum && !t.IsBuiltIn).ToList();
        if (!enumTypes.Any())
            return;

        context.BeforeEnumsGeneration();

        enumTypes.ForEach(t => GenerateEnum(context, t));

        context.AfterEnumsGeneration();
    }

    private void GenerateQueryBuilders(GenerationContext context)
    {
        if (IsQueryBuilderGenerationDisabled(context.ObjectTypes))
            return;

        context.BeforeQueryBuildersGeneration();

        var complexTypes = context.Schema.Types.Where(t => IsComplexType(t.Kind) && !t.IsBuiltIn).ToList();
        var complexTypeDictionary = complexTypes.ToDictionary(t => t.Name);
        complexTypes.ForEach(t => GenerateQueryBuilder(context, t, complexTypeDictionary));

        context.AfterQueryBuildersGeneration();
    }

    private static void GenerateBaseClasses(GenerationContext context)
    {
        if (!context.ObjectTypes.HasFlag(GeneratedObjectType.BaseClasses))
            return;

        context.BeforeBaseClassGeneration();

        var indentation = GetIndentation(context.Indentation);

        using var reader = new StreamReader(typeof(GraphQlGenerator).GetTypeInfo().Assembly.GetManifestResourceStream("GraphQlClientGenerator.BaseClasses.cs"));
        do
        {
            var line = reader.ReadLine();
            if (line is null)
                break;

            context.Writer.Write(indentation);
            context.Writer.WriteLine(line.Replace("GRAPHQL_GENERATOR_DISABLE_NEWTONSOFT_JSON", PreprocessorDirectiveDisableNewtonsoftJson));
        } while (true);

        context.AfterBaseClassGeneration();
    }

    private static bool IsQueryBuilderGenerationDisabled(GeneratedObjectType objectTypes) => !objectTypes.HasFlag(GeneratedObjectType.QueryBuilders);

    private static bool IsDataClassGenerationDisabled(GeneratedObjectType objectTypes) => !objectTypes.HasFlag(GeneratedObjectType.DataClasses);

    private static string GetIndentation(int size) => new(' ', size);

    private static IReadOnlyDictionary<string, GraphQlType> GetComplexTypes(GraphQlSchema schema) =>
        schema.Types.Where(t => IsComplexType(t.Kind) && !t.IsBuiltIn).ToDictionary(t => t.Name);

    private static IEnumerable<GraphQlType> GetInputObjectTypes(GraphQlSchema schema) =>
        schema.Types.Where(t => t.Kind == GraphQlTypeKind.InputObject && !t.IsBuiltIn);

    private static void FindAllReferencedObjectTypes(GraphQlSchema schema, GraphQlType type, ISet<string> objectTypes)
    {
        foreach (var member in (IEnumerable<IGraphQlMember>)type.InputFields ?? type.Fields)
        {
            var unwrappedType = member.Type.UnwrapIfNonNull();
            GraphQlType memberType;
            switch (unwrappedType.Kind)
            {
                case GraphQlTypeKind.Object:
                    objectTypes.Add(unwrappedType.Name);
                    memberType = schema.Types.Single(t => t.Name == unwrappedType.Name);
                    FindAllReferencedObjectTypes(schema, memberType, objectTypes);
                    break;

                case GraphQlTypeKind.List:
                    var itemType = unwrappedType.OfType.UnwrapIfNonNull();
                    if (IsComplexType(itemType.Kind))
                    {
                        memberType = schema.Types.Single(t => t.Name == itemType.Name);
                        FindAllReferencedObjectTypes(schema, memberType, objectTypes);
                    }

                    break;
            }
        }
    }

    private void GenerateInputObjects(GenerationContext context)
    {
        if (IsDataClassGenerationDisabled(context.ObjectTypes))
            return;

        var inputObjectTypes = GetInputObjectTypes(context.Schema).ToArray();
        if (!inputObjectTypes.Any())
            return;

        context.BeforeInputClassesGeneration();

        foreach (var inputObjectType in inputObjectTypes)
        {
            GenerateDataClass(
                context,
                GetCSharpClassName(context, inputObjectType.Name),
                inputObjectType,
                "IGraphQlInputObject",
                () => GenerateInputDataClassBody(inputObjectType, inputObjectType.InputFields, context));
        }

        context.AfterInputClassesGeneration();
    }

    private void GenerateDataClasses(GenerationContext context)
    {
        if (IsDataClassGenerationDisabled(context.ObjectTypes))
            return;

        var complexTypes = GetComplexTypes(context.Schema);
        if (!complexTypes.Any())
            return;

        context.BeforeDataClassesGeneration();

        foreach (var complexType in complexTypes.Values)
        {
            var hasInputReference = context.ReferencedObjectTypes.Contains(complexType.Name);
            var fieldsToGenerate = GetFieldsToGenerate(complexType, complexTypes);
            var isInterface = complexType.Kind == GraphQlTypeKind.Interface;
            var csharpTypeName = GetCSharpClassName(context, complexType.Name);

            void GenerateBody(bool isInterfaceMember)
            {
                var writer = context.Writer;
                if (hasInputReference)
                    GenerateInputDataClassBody(complexType, fieldsToGenerate, context);
                else if (fieldsToGenerate is not null)
                {
                    var generateBackingFields = _configuration.PropertyGeneration == PropertyGenerationOption.BackingField && !isInterfaceMember;
                    if (generateBackingFields)
                    {
                        var indentation = GetIndentation(context.Indentation);

                        foreach (var field in fieldsToGenerate)
                        {
                            writer.Write(indentation);
                            writer.Write("    private ");
                            writer.Write(GetDataPropertyType(context, complexType, field).NetTypeName);
                            writer.Write(" ");
                            writer.Write(GetBackingFieldName(field.Name));
                            writer.WriteLine(";");
                        }

                        writer.WriteLine();
                    }

                    foreach (var field in fieldsToGenerate)
                        GenerateDataProperty(
                            complexType,
                            field,
                            NamingHelper.ToPascalCase(field.Name),
                            isInterfaceMember,
                            field.IsDeprecated,
                            field.DeprecationReason,
                            true,
                            (_, backingFieldName) =>
                                writer.Write(generateBackingFields ? _configuration.PropertyAccessorBodyWriter(backingFieldName, GetDataPropertyType(context, complexType, field)) : " { get; set; }"),
                            context);
                }
            }

            var interfacesToImplement = new List<string>();
            if (isInterface)
            {
                interfacesToImplement.Add(GenerateInterface(context, csharpTypeName, complexType, () => GenerateBody(true)));
            }
            else if (complexType.Interfaces?.Count > 0)
            {
                var fieldNames = new HashSet<string>(fieldsToGenerate.Select(f => f.Name));

                foreach (var @interface in complexType.Interfaces)
                {
                    var csharpInterfaceName = GetCSharpMemberName(@interface.Name);
                    var interfaceName = $"I{_configuration.ClassPrefix}{csharpInterfaceName}{_configuration.ClassSuffix}";
                    interfacesToImplement.Add(interfaceName);

                    foreach (var interfaceField in complexTypes[@interface.Name].Fields.Where(FilterDeprecatedFields))
                        if (fieldNames.Add(interfaceField.Name))
                            fieldsToGenerate.Add(interfaceField);
                }
            }

            if (hasInputReference)
                interfacesToImplement.Add("IGraphQlInputObject");

            if (!isInterface)
                GenerateDataClass(context, csharpTypeName, complexType, String.Join(", ", interfacesToImplement), () => GenerateBody(false));
        }

        context.AfterDataClassesGeneration();
    }

    private string GetCSharpClassName(GenerationContext context, string graphQlName)
    {
        var csharpClassName = graphQlName;
        if (UseCustomClassNameIfDefined(ref csharpClassName))
            return csharpClassName;

        return context.NameCollisionMapping.TryGetValue(graphQlName, out csharpClassName) ? csharpClassName : NamingHelper.ToPascalCase(graphQlName);
    }

    private string GetCSharpMemberName(string graphQlName)
    {
        var csharpMemberName = graphQlName;
        if (!UseCustomClassNameIfDefined(ref csharpMemberName))
            csharpMemberName = NamingHelper.ToPascalCase(csharpMemberName);

        return csharpMemberName;
    }

    private static string GetBackingFieldName(string graphQlFieldName) => $"_{NamingHelper.LowerFirst(NamingHelper.ToPascalCase(graphQlFieldName))}";

    private static bool IsComplexType(GraphQlTypeKind graphQlTypeKind) =>
        graphQlTypeKind is GraphQlTypeKind.Object or GraphQlTypeKind.Interface or GraphQlTypeKind.Union;

    private void GenerateInputDataClassBody(GraphQlType type, IEnumerable<IGraphQlMember> members, GenerationContext context)
    {
        var writer = context.Writer;
        var indentation = GetIndentation(context.Indentation);

        var fieldNameMembers = new Dictionary<string, (IGraphQlMember Member, int? NameExtension)>();
        foreach (var member in members)
        {
            var fieldName = GetBackingFieldName(member.Name);
            var originalFieldName = fieldName;
            var collidingNameExtendingIndex = 1;
            while (fieldNameMembers.ContainsKey(fieldName))
                fieldName = $"{originalFieldName}{++collidingNameExtendingIndex}";

            fieldNameMembers.Add(fieldName, (member, collidingNameExtendingIndex == 1 ? null : collidingNameExtendingIndex));

            writer.Write(indentation);
            writer.Write("    private InputPropertyInfo ");
            writer.Write(fieldName);
            writer.WriteLine(";");
        }

        writer.WriteLine();

        var useCompatibleSyntax = _configuration.CSharpVersion == CSharpVersion.Compatible;

        foreach (var kvp in fieldNameMembers)
            GenerateDataProperty(
                type,
                kvp.Value.Member,
                NamingHelper.ToPascalCase(kvp.Value.Member.Name) + kvp.Value.NameExtension,
                false,
                false,
                null,
                true,
                (t, _) =>
                {
                    writer.WriteLine();
                    writer.Write(indentation);
                    writer.WriteLine("    {");
                    writer.Write(indentation);
                    writer.Write("        get");
                    writer.Write(useCompatibleSyntax ? " { return " : " => ");
                    writer.Write("(");
                    writer.Write(t.NetTypeName);
                    writer.Write(")");
                    writer.Write(kvp.Key);
                    writer.Write(".Value;");

                    if (useCompatibleSyntax)
                        writer.Write(" }");

                    writer.WriteLine();

                    writer.Write(indentation);
                    writer.Write("        set");
                    writer.Write(useCompatibleSyntax ? " { " : " => ");
                    writer.Write(kvp.Key);
                    writer.Write(" = new InputPropertyInfo { Name = \"");
                    writer.Write(kvp.Value.Member.Name);
                    writer.Write("\", Value = value");

                    if (!String.IsNullOrEmpty(t.FormatMask))
                    {
                        writer.Write(", FormatMask = \"");
                        writer.Write(t.FormatMask.Replace("\"", "\\\""));
                        writer.Write("\"");
                    }

                    writer.Write(" };");

                    if (useCompatibleSyntax)
                        writer.Write(" }");

                    writer.WriteLine();
                    writer.Write(indentation);
                    writer.WriteLine("    }");
                },
                context);

        writer.Write(indentation);
        writer.WriteLine("    IEnumerable<InputPropertyInfo> IGraphQlInputObject.GetPropertyValues()");
        writer.Write(indentation);
        writer.WriteLine("    {");

        foreach (var fieldName in fieldNameMembers.Keys)
        {
            writer.Write(indentation);
            writer.Write("        if (");
            writer.Write(fieldName);
            writer.Write(".Name != null) yield return ");
            writer.Write(fieldName);
            writer.WriteLine(";");
        }

        writer.Write(indentation);
        writer.WriteLine("    }");
    }

    private string GenerateInterface(GenerationContext context, string interfaceName, GraphQlType graphQlType, Action generateInterfaceBody) =>
        GenerateFileMember(context, "interface", interfaceName, graphQlType, null, generateInterfaceBody);

    private string GenerateDataClass(GenerationContext context, string typeName, GraphQlType graphQlType, string baseTypeName, Action generateClassBody) =>
        GenerateFileMember(context, "class", typeName, graphQlType, baseTypeName, generateClassBody);

    private string GenerateFileMember(GenerationContext context, string memberType, string typeName, GraphQlType graphQlType, string baseTypeName, Action generateFileMemberBody)
    {
        typeName = $"{_configuration.ClassPrefix}{typeName}{_configuration.ClassSuffix}";

        if (memberType == "interface")
            typeName = $"I{typeName}";

        ValidateClassName(typeName);

        context.BeforeDataClassGeneration(typeName);

        var writer = context.Writer;

        GenerateCodeComments(writer, graphQlType.Description, context.Indentation);

        var indentation = GetIndentation(context.Indentation);

        if (graphQlType.Interfaces?.Count > 0)
        {
            writer.Write(indentation);
            writer.Write("[GraphQlObjectType(\"");
            writer.Write(graphQlType.Name);
            writer.WriteLine("\")]");
        }
            
        writer.Write(indentation);
        writer.Write(GetMemberAccessibility());
        writer.Write(" ");

        if (_configuration.GeneratePartialClasses)
            writer.Write("partial ");

        writer.Write(memberType);
        writer.Write(" ");
        writer.Write(typeName);

        if (!String.IsNullOrEmpty(baseTypeName))
        {
            writer.Write(" : ");
            writer.Write(baseTypeName);
        }

        writer.WriteLine();
        writer.Write(indentation);
        writer.WriteLine("{");

        generateFileMemberBody();

        writer.Write(indentation);
        writer.WriteLine("}");

        context.AfterDataClassGeneration(typeName);

        return typeName;
    }

    private static IEnumerable<GraphQlField> GetFragments(GraphQlType type, IReadOnlyDictionary<string, GraphQlType> complexTypes)
    {
        var fragments = new List<GraphQlField>();
        if (type.Kind != GraphQlTypeKind.Union && type.Kind != GraphQlTypeKind.Interface)
            return fragments;

        foreach (var possibleType in type.PossibleTypes)
            if (complexTypes.TryGetValue(possibleType.Name, out var consistOfType) && consistOfType.Fields is not null)
                fragments.Add(
                    new GraphQlField
                    {
                        Name = consistOfType.Name,
                        Description = consistOfType.Description,
                        Type =
                            new GraphQlFieldType
                            {
                                Name = consistOfType.Name,
                                Kind = consistOfType.Kind
                            }
                    });

        return fragments;
    }

    private List<GraphQlField> GetFieldsToGenerate(GraphQlType type, IReadOnlyDictionary<string, GraphQlType> complexTypes)
    {
        var typeFields = type.Fields;
        if (type.Kind == GraphQlTypeKind.Union)
        {
            var unionFields = new List<GraphQlField>();
            var unionFieldNames = new HashSet<string>();
            foreach (var possibleType in type.PossibleTypes)
                if (complexTypes.TryGetValue(possibleType.Name, out var consistOfType) && consistOfType.Fields is not null)
                    unionFields.AddRange(consistOfType.Fields.Where(f => unionFieldNames.Add(f.Name)));

            typeFields = unionFields;
        }

        return typeFields?.Where(FilterDeprecatedFields).ToList();
    }

    private string AddQuestionMarkIfNullableReferencesEnabled(string dataTypeIdentifier) => AddQuestionMarkIfNullableReferencesEnabled(_configuration, dataTypeIdentifier);

    internal static string AddQuestionMarkIfNullableReferencesEnabled(GraphQlGeneratorConfiguration configuration, string dataTypeIdentifier) =>
        configuration.CSharpVersion == CSharpVersion.NewestWithNullableReferences ? dataTypeIdentifier + "?" : dataTypeIdentifier;

    private bool UseCustomClassNameIfDefined(ref string typeName)
    {
        if (!_configuration.CustomClassNameMapping.TryGetValue(typeName, out var customTypeName))
            return false;

        ValidateClassName(customTypeName);
        typeName = customTypeName;
        return true;
    }

    private string GetMemberAccessibility() =>
        _configuration.MemberAccessibility == MemberAccessibility.Internal ? "internal" : "public";

    private bool FilterDeprecatedFields(GraphQlField field) =>
        !field.IsDeprecated || _configuration.IncludeDeprecatedFields;

    private void GenerateDataProperty(
        GraphQlType baseType,
        IGraphQlMember member,
        string propertyName,
        bool isInterfaceMember,
        bool isDeprecated,
        string deprecationReason,
        bool decorateWithJsonPropertyAttribute,
        WriteDataClassPropertyBodyDelegate writeBody,
        GenerationContext context)
    {
        var propertyTypeDescription = GetDataPropertyType(context, baseType, member);
        var propertyTypeName = propertyTypeDescription.NetTypeName;

        var writer = context.Writer;

        GenerateCodeComments(writer, member.Description, context.Indentation + 4);

        var indentation = GetIndentation(context.Indentation);

        if (isDeprecated)
        {
            deprecationReason = String.IsNullOrWhiteSpace(deprecationReason) ? null : $"(@\"{deprecationReason.Replace("\"", "\"\"")}\")";
            writer.Write(indentation);
            writer.WriteLine($"    [Obsolete{deprecationReason}]");
        }

        if (decorateWithJsonPropertyAttribute)
        {
            decorateWithJsonPropertyAttribute =
                _configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.Always ||
                !String.Equals(
                    member.Name,
                    propertyName.TrimStart('@'),
                    _configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.CaseInsensitive ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);

            if (_configuration.JsonPropertyGeneration is JsonPropertyGenerationOption.Never or JsonPropertyGenerationOption.UseDefaultAlias)
                decorateWithJsonPropertyAttribute = false;
        }

        var fieldType = member.Type.UnwrapIfNonNull();
        var isGraphQlInterfaceJsonConverterRequired = fieldType.Kind == GraphQlTypeKind.Interface || fieldType.Kind == GraphQlTypeKind.List && UnwrapListItemType(fieldType, out _).UnwrapIfNonNull().Kind == GraphQlTypeKind.Interface;
        var isBaseTypeInputObject = baseType.Kind == GraphQlTypeKind.InputObject;
        var isPreprocessorDirectiveDisableNewtonsoftJsonRequired = !isInterfaceMember && decorateWithJsonPropertyAttribute || isGraphQlInterfaceJsonConverterRequired || isBaseTypeInputObject;
        if (isPreprocessorDirectiveDisableNewtonsoftJsonRequired)
        {
            writer.Write(indentation);
            writer.Write("    #if !");
            writer.WriteLine(PreprocessorDirectiveDisableNewtonsoftJson);
        }

        if (!isInterfaceMember && decorateWithJsonPropertyAttribute)
        {
            writer.Write(indentation);
            writer.WriteLine($"    [JsonProperty(\"{member.Name}\")]");
        }

        if (isGraphQlInterfaceJsonConverterRequired)
        {
            writer.Write(indentation);
            writer.WriteLine("    [JsonConverter(typeof(GraphQlInterfaceJsonConverter))]");
        }
        else if (isBaseTypeInputObject)
        {
            writer.Write(indentation);
            writer.WriteLine($"    [JsonConverter(typeof(QueryBuilderParameterConverter<{propertyTypeName}>))]");
            propertyTypeName = AddQuestionMarkIfNullableReferencesEnabled($"QueryBuilderParameter<{propertyTypeName}>");
        }

        if (isPreprocessorDirectiveDisableNewtonsoftJsonRequired)
        {
            writer.Write(indentation);
            writer.WriteLine("    #endif");
        }

        writer.Write(indentation);
        writer.Write("    ");

        if (!isInterfaceMember)
            writer.Write("public ");

        writer.Write(propertyTypeName);
        writer.Write(" ");
        writer.Write(propertyName);

        writeBody(propertyTypeDescription with { NetTypeName = propertyTypeName }, GetBackingFieldName(member.Name));

        writer.WriteLine();
    }

    private ScalarFieldTypeDescription GetDataPropertyType(GenerationContext context, GraphQlType baseType, IGraphQlMember member)
    {
        var fieldType = member.Type.UnwrapIfNonNull();

        switch (fieldType.Kind)
        {
            case GraphQlTypeKind.Object:
            case GraphQlTypeKind.Interface:
            case GraphQlTypeKind.Union:
            case GraphQlTypeKind.InputObject:
                var fieldTypeName = GetCSharpClassName(context, fieldType.Name);
                var propertyType = $"{_configuration.ClassPrefix}{fieldTypeName}{_configuration.ClassSuffix}";
                if (fieldType.Kind == GraphQlTypeKind.Interface)
                    propertyType = $"I{propertyType}";

                return ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled(propertyType));

            case GraphQlTypeKind.Enum:
                return _configuration.ScalarFieldTypeMappingProvider.GetCustomScalarFieldType(_configuration, baseType, member.Type, member.Name);

            case GraphQlTypeKind.List:
                var itemType = UnwrapListItemType(fieldType, out var netCollectionOpenType);
                var unwrappedItemType = itemType?.UnwrapIfNonNull();
                if (unwrappedItemType is null)
                    throw ListItemTypeResolutionFailedException(baseType.Name, fieldType.Name);

                var itemTypeName = GetCSharpClassName(context, unwrappedItemType.Name);

                var netItemType =
                    IsUnknownObjectScalar(baseType, member.Name, itemType)
                        ? "object"
                        : $"{(unwrappedItemType.Kind == GraphQlTypeKind.Interface ? "I" : null)}{_configuration.ClassPrefix}{itemTypeName}{_configuration.ClassSuffix}";

                var suggestedScalarNetType = ScalarToNetType(baseType, member.Name, itemType).NetTypeName.TrimEnd('?');
                if (!String.Equals(suggestedScalarNetType, "object") && !String.Equals(suggestedScalarNetType, "object?") &&
                    !suggestedScalarNetType.TrimEnd().EndsWith("System.Object") && !suggestedScalarNetType.TrimEnd().EndsWith("System.Object?"))
                    netItemType = suggestedScalarNetType;

                if (itemType.Kind != GraphQlTypeKind.NonNull)
                    netItemType = AddQuestionMarkIfNullableReferencesEnabled(netItemType);

                var netCollectionType = String.Format(netCollectionOpenType, netItemType);
                return ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled(netCollectionType));

            case GraphQlTypeKind.Scalar:
                return GetScalarNetType(fieldType.Name, baseType, member);

            default:
                return ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled("string"));
        }
    }

    private ScalarFieldTypeDescription GetScalarNetType(string scalarTypeName, GraphQlType baseType, IGraphQlMember member) =>
        scalarTypeName
            switch
            {
                GraphQlTypeBase.GraphQlTypeScalarInteger => GetIntegerNetType(baseType, member.Type, member.Name),
                GraphQlTypeBase.GraphQlTypeScalarString => GetCustomScalarNetType(baseType, member.Type, member.Name),
                GraphQlTypeBase.GraphQlTypeScalarFloat => GetFloatNetType(baseType, member.Type, member.Name),
                GraphQlTypeBase.GraphQlTypeScalarBoolean => ConvertToTypeDescription(GetBooleanNetType(baseType, member.Type, member.Name)),
                GraphQlTypeBase.GraphQlTypeScalarId => GetIdNetType(baseType, member.Type, member.Name),
                _ => GetCustomScalarNetType(baseType, member.Type, member.Name)
            };

    private string GetBooleanNetType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName) =>
        _configuration.BooleanTypeMapping switch
        {
            BooleanTypeMapping.Boolean => "bool?",
            BooleanTypeMapping.Custom => _configuration.ScalarFieldTypeMappingProvider.GetCustomScalarFieldType(_configuration, baseType, valueType, valueName).NetTypeName,
            _ => throw new InvalidOperationException($"'{_configuration.BooleanTypeMapping}' not supported")
        };

    private ScalarFieldTypeDescription GetFloatNetType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName) =>
        _configuration.FloatTypeMapping switch
        {
            FloatTypeMapping.Decimal => ConvertToTypeDescription("decimal?"),
            FloatTypeMapping.Float => ConvertToTypeDescription("float?"),
            FloatTypeMapping.Double => ConvertToTypeDescription("double?"),
            FloatTypeMapping.Custom => _configuration.ScalarFieldTypeMappingProvider.GetCustomScalarFieldType(_configuration, baseType, valueType, valueName),
            _ => throw new InvalidOperationException($"'{_configuration.FloatTypeMapping}' not supported")
        };

    private ScalarFieldTypeDescription GetIntegerNetType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName) =>
        _configuration.IntegerTypeMapping switch
        {
            IntegerTypeMapping.Int32 => ConvertToTypeDescription("int?"),
            IntegerTypeMapping.Int16 => ConvertToTypeDescription("short?"),
            IntegerTypeMapping.Int64 => ConvertToTypeDescription("long?"),
            IntegerTypeMapping.Custom => _configuration.ScalarFieldTypeMappingProvider.GetCustomScalarFieldType(_configuration, baseType, valueType, valueName),
            _ => throw new InvalidOperationException($"'{_configuration.IntegerTypeMapping}' not supported")
        };

    private ScalarFieldTypeDescription GetIdNetType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName) =>
        _configuration.IdTypeMapping switch
        {
            IdTypeMapping.String => ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled("string")),
            IdTypeMapping.Guid => ConvertToTypeDescription("Guid?"),
            IdTypeMapping.Object => ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled("object")),
            IdTypeMapping.Custom => _configuration.ScalarFieldTypeMappingProvider.GetCustomScalarFieldType(_configuration, baseType, valueType, valueName),
            _ => throw new InvalidOperationException($"'{_configuration.IdTypeMapping}' not supported")
        };

    private static InvalidOperationException ListItemTypeResolutionFailedException(string typeName, string fieldName) =>
        FieldTypeResolutionFailedException(typeName, fieldName, "list item type was not resolved; nested collections too deep");

    private static InvalidOperationException FieldTypeResolutionFailedException(string typeName, string fieldName, string reason) =>
        new($"field type resolution failed - type: {typeName}; field: {fieldName}{(reason is null ? null : "; reason: " + reason)}");

    private void GenerateQueryBuilder(GenerationContext context, GraphQlType type, IReadOnlyDictionary<string, GraphQlType> complexTypes)
    {
        var schema = context.Schema;
        var typeName = GetCSharpMemberName(type.Name);
        var className = $"{_configuration.ClassPrefix}{typeName}QueryBuilder{_configuration.ClassSuffix}";

        var fields = type.Kind == GraphQlTypeKind.Union ? null : GetFieldsToGenerate(type, complexTypes);
        if (fields?.Count == 0)
            return;

        ValidateClassName(className);

        context.BeforeQueryBuilderGeneration(className);

        var writer = context.Writer;
        var indentation = GetIndentation(context.Indentation);
        writer.Write(indentation);
        writer.Write(GetMemberAccessibility());
        writer.Write(" ");

        if (_configuration.GeneratePartialClasses)
            writer.Write("partial ");

        writer.Write("class ");
        writer.Write(className);
        writer.WriteLine($" : GraphQlQueryBuilder<{className}>");
        writer.Write(indentation);
        writer.WriteLine("{");
        writer.Write(indentation);
        writer.Write("    private static readonly GraphQlFieldMetadata[] AllFieldMetadata =");

        if (fields is null)
        {
            writer.WriteLine(" new GraphQlFieldMetadata[0];");
            writer.WriteLine();
        }
        else
        {
            writer.WriteLine();

            var fieldMetadataIndentation = indentation;

            if (_configuration.CSharpVersion == CSharpVersion.Compatible)
            {
                writer.Write(indentation);
                writer.WriteLine("        new []");
                fieldMetadataIndentation = $"{indentation}    ";
            }

            writer.Write(fieldMetadataIndentation);
            writer.WriteLine("    {");

            for (var i = 0; i < fields.Count; i++)
            {
                var comma = i == fields.Count - 1 ? null : ",";
                var field = fields[i];
                var fieldType = field.Type.UnwrapIfNonNull();
                var isList = fieldType.Kind == GraphQlTypeKind.List;
                var treatUnknownObjectAsComplex = IsUnknownObjectScalar(type, field.Name, fieldType) && !_configuration.TreatUnknownObjectAsScalar;
                var isComplex = isList || treatUnknownObjectAsComplex || IsComplexType(fieldType.Kind);

                writer.Write(fieldMetadataIndentation);
                writer.Write("        new GraphQlFieldMetadata { Name = \"");
                writer.Write(field.Name);
                writer.Write('"');

                var csharpPropertyName = NamingHelper.ToPascalCase(field.Name);
                if (_configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.UseDefaultAlias && !String.Equals(field.Name, csharpPropertyName, StringComparison.OrdinalIgnoreCase))
                {
                    writer.Write(", DefaultAlias = \"");
                    writer.Write(NamingHelper.LowerFirst(csharpPropertyName));
                    writer.Write('"');
                }

                if (isComplex)
                {
                    writer.Write(", IsComplex = true");

                    if (isList)
                    {
                        var itemType = UnwrapListItemType(fieldType, out _)?.UnwrapIfNonNull();
                        fieldType = itemType ?? throw ListItemTypeResolutionFailedException(type.Name, field.Name);
                    }

                    if (fieldType.Kind != GraphQlTypeKind.Scalar && fieldType.Kind != GraphQlTypeKind.Enum && fieldType.Kind != GraphQlTypeKind.List)
                    {
                        var fieldTypeName = fieldType.Name;
                        if (fieldTypeName is null)
                            throw FieldTypeResolutionFailedException(type.Name, field.Name, null);

                        fieldTypeName = GetCSharpMemberName(fieldTypeName);
                            
                        writer.Write($", QueryBuilderType = typeof({_configuration.ClassPrefix}{fieldTypeName}QueryBuilder{_configuration.ClassSuffix})");
                    }
                }

                writer.WriteLine($" }}{comma}");
            }

            writer.Write(fieldMetadataIndentation);
            writer.WriteLine("    };");
            writer.WriteLine();
        }

        GraphQlDirectiveLocation directiveLocation;
        if (type.Name == schema.QueryType?.Name)
            directiveLocation = GraphQlDirectiveLocation.Query;
        else if (type.Name == schema.MutationType?.Name)
            directiveLocation = GraphQlDirectiveLocation.Mutation;
        else if (type.Name == schema.SubscriptionType?.Name)
            directiveLocation = GraphQlDirectiveLocation.Subscription;
        else
            directiveLocation = GraphQlDirectiveLocation.Field;

        if (type.Kind is GraphQlTypeKind.Interface or GraphQlTypeKind.Union)
        {
            var constructorIndentation = indentation + "    ";
            writer.Write(constructorIndentation);
            writer.WriteLine($"public {className}()");
            writer.Write(constructorIndentation);
            writer.WriteLine("{");
            writer.Write(constructorIndentation);
            writer.WriteLine("    WithTypeName();");
            writer.Write(constructorIndentation);
            writer.WriteLine("}");
            writer.WriteLine();
        }

        var hasQueryPrefix = directiveLocation != GraphQlDirectiveLocation.Field;

        WriteOverrideProperty("protected", "string", "TypeName", $"\"{type.Name}\"", indentation, writer);

        WriteOverrideProperty("public", "IReadOnlyList<GraphQlFieldMetadata>", "AllFields", "AllFieldMetadata", indentation, writer);

        string ReturnPrefix(bool requiresFullBody) => requiresFullBody ? indentation + "        return " : String.Empty;

        var useCompatibleSyntax = _configuration.CSharpVersion == CSharpVersion.Compatible;
        var stringDataType = AddQuestionMarkIfNullableReferencesEnabled("string");

        if (hasQueryPrefix)
        {
            writer.Write(indentation);
            writer.Write("    public ");
            writer.Write(className);
            writer.Write("(");
            writer.Write(stringDataType);
            writer.Write(" operationName = null) : base(\"");
            writer.Write(directiveLocation.ToString().ToLowerInvariant());
            writer.WriteLine("\", operationName)");
            writer.Write(indentation);
            writer.WriteLine("    {");
            writer.Write(indentation);
            writer.WriteLine("    }");
            writer.WriteLine();

            writer.Write(indentation);
            writer.Write($"    public {className} WithParameter<T>(GraphQlQueryParameter<T> parameter)");
            WriteQueryBuilderMethodBody(
                useCompatibleSyntax,
                indentation,
                writer,
                () => writer.WriteLine($"{ReturnPrefix(useCompatibleSyntax)}WithParameterInternal(parameter);"));

            writer.WriteLine();
        }

        var fragments = GetFragments(type, complexTypes);
        fields ??= new List<GraphQlField>();
        var firstFragmentIndex = fields.Count;
        fields.AddRange(fragments);

        for (var i = 0; i < fields.Count; i++)
        {
            var field = fields[i];
            var fieldType = field.Type.UnwrapIfNonNull();
            if (fieldType.Kind == GraphQlTypeKind.List)
                fieldType = fieldType.OfType;
                
            fieldType = fieldType.UnwrapIfNonNull();
            var isFragment = i >= firstFragmentIndex;
            var argumentDefinitions = ResolveParameterDefinitions(context, type, field.Args);
            var argumentCollectionVariableName = "args";
            var counter = 0;
            while (argumentDefinitions.Any(a => a.NetParameterName == argumentCollectionVariableName))
                switch (argumentCollectionVariableName)
                {
                    case "args":
                        argumentCollectionVariableName = "inputArgs";
                        break;

                    default:
                        argumentCollectionVariableName = $"inputArgs{(counter == 0 ? null : counter)}";
                        counter++;
                        break;
                }

            var methodParameters =
                String.Join(
                    ", ",
                    argumentDefinitions
                        .OrderByDescending(d => d.Argument.Type.Kind == GraphQlTypeKind.NonNull)
                        .Select(d => d.NetParameterDefinitionClause));

            var requiresFullBody = useCompatibleSyntax || argumentDefinitions.Any();
            var returnPrefix = ReturnPrefix(requiresFullBody);
            var csharpPropertyName = NamingHelper.ToPascalCase(field.Name);

            void WriteAliasParameter()
            {
                writer.Write(stringDataType);
                writer.Write(" alias = ");

                if (_configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.UseDefaultAlias && !String.Equals(field.Name, csharpPropertyName, StringComparison.OrdinalIgnoreCase))
                {
                    writer.Write('"');
                    writer.Write(NamingHelper.LowerFirst(csharpPropertyName));
                    writer.Write('"');
                }
                else
                    writer.Write("null");
            }

            if (fieldType.Kind is GraphQlTypeKind.Scalar or GraphQlTypeKind.Enum or GraphQlTypeKind.List)
            {
                writer.Write(indentation);
                writer.Write("    public ");
                writer.Write(className);
                writer.Write(" With");
                writer.Write(csharpPropertyName);
                writer.Write("(");
                writer.Write(methodParameters);

                if (!String.IsNullOrEmpty(methodParameters))
                    writer.Write(", ");

                WriteAliasParameter();
                    
                var fieldDirectiveParameterNameList = WriteDirectiveParameterList(schema, argumentDefinitions, GraphQlDirectiveLocation.Field, writer);
                    
                writer.Write(")");

                WriteQueryBuilderMethodBody(
                    requiresFullBody,
                    indentation,
                    writer,
                    () =>
                    {
                        AppendArgumentDictionary(indentation, writer, argumentDefinitions, argumentCollectionVariableName);

                        writer.Write(returnPrefix);
                        writer.Write("WithScalarField(\"");
                        writer.Write(field.Name);
                        writer.Write("\", alias, ");
                        writer.Write(fieldDirectiveParameterNameList);

                        if (argumentDefinitions.Count > 0)
                        {
                            writer.Write(", ");
                            writer.Write(argumentCollectionVariableName);
                        }

                        writer.WriteLine(");");
                    });
            }
            else
            {
                var fieldTypeName = fieldType.Name;
                if (String.IsNullOrEmpty(fieldTypeName))
                    throw FieldTypeResolutionFailedException(type.Name, field.Name, null);

                fieldTypeName = GetCSharpMemberName(fieldTypeName);

                var builderParameterName = NamingHelper.LowerFirst(fieldTypeName);
                writer.Write(indentation);
                writer.Write($"    public {className} With{csharpPropertyName}{(isFragment ? "Fragment" : null)}({_configuration.ClassPrefix}{fieldTypeName}QueryBuilder{_configuration.ClassSuffix} {builderParameterName}QueryBuilder");

                if (argumentDefinitions.Count > 0)
                {
                    writer.Write(", ");
                    writer.Write(methodParameters);
                }

                if (!isFragment)
                {
                    writer.Write(", ");
                    WriteAliasParameter();
                }

                var fieldDirectiveParameterNameList = WriteDirectiveParameterList(schema, argumentDefinitions, GraphQlDirectiveLocation.Field, writer);

                writer.Write(")");

                WriteQueryBuilderMethodBody(
                    requiresFullBody,
                    indentation,
                    writer,
                    () =>
                    {
                        AppendArgumentDictionary(indentation, writer, argumentDefinitions, argumentCollectionVariableName);

                        writer.Write(returnPrefix);
                        writer.Write("With");

                        if (isFragment)
                            writer.Write("Fragment(");
                        else
                        {
                            writer.Write("ObjectField(\"");
                            writer.Write(field.Name);
                            writer.Write("\", alias, ");
                        }

                        writer.Write(builderParameterName);
                        writer.Write("QueryBuilder");

                        writer.Write(", ");
                        writer.Write(fieldDirectiveParameterNameList);

                        if (argumentDefinitions.Count > 0)
                        {
                            writer.Write(", ");
                            writer.Write(argumentCollectionVariableName);
                        }

                        writer.WriteLine(");");
                    });
            }

            if (!isFragment)
            {
                writer.WriteLine();

                writer.Write(indentation);
                writer.Write($"    public {className} Except{csharpPropertyName}()");

                WriteQueryBuilderMethodBody(
                    useCompatibleSyntax,
                    indentation,
                    writer,
                    () => writer.WriteLine($"{ReturnPrefix(useCompatibleSyntax)}ExceptField(\"{field.Name}\");"));
            }

            if (i < fields.Count - 1)
                writer.WriteLine();
        }

        writer.Write(indentation);
        writer.WriteLine("}");

        context.AfterQueryBuilderGeneration(className);
    }

    private IList<QueryBuilderParameterDefinition> ResolveParameterDefinitions(GenerationContext context, GraphQlType type, IEnumerable<GraphQlArgument> graphQlArguments)
    {
        if (graphQlArguments is null)
            return Array.Empty<QueryBuilderParameterDefinition>();

        var parameterDefinitions = new List<QueryBuilderParameterDefinition>();
        var collidingNames = new Dictionary<string, int>();
        foreach (var argument in graphQlArguments.Where(a => IsCompatibleArgument(a.Type)))
        {
            var netParameterName = NamingHelper.ToValidCSharpName(NamingHelper.LowerFirst(NamingHelper.ToPascalCase(argument.Name)));
            collidingNames[netParameterName] = collidingNames.TryGetValue(netParameterName, out var extendingIndex) ? extendingIndex + 1 : 1;

            if (extendingIndex > 0)
                netParameterName = $"{netParameterName}{++extendingIndex}";

            parameterDefinitions.Add(BuildMethodParameterDefinition(context, type, argument, netParameterName));
        }

        return parameterDefinitions;

        static bool IsCompatibleArgument(GraphQlFieldType argumentType)
        {
            argumentType = argumentType.UnwrapIfNonNull();
            return
                argumentType.Kind switch
                {
                    GraphQlTypeKind.Scalar => true,
                    GraphQlTypeKind.Enum => true,
                    GraphQlTypeKind.InputObject => true,
                    GraphQlTypeKind.List => IsCompatibleArgument(argumentType.OfType),
                    _ => false
                };
        }
    }

    private GraphQlFieldType UnwrapListItemType(GraphQlFieldType type, out string netCollectionOpenType)
    {
        var levels = 0;

        var nullableSymbols = new List<string> { String.Empty };

        while (true)
        {
            levels++;

            var unwrappedType = type.OfType?.UnwrapIfNonNull();
            if (unwrappedType is null)
            {
                netCollectionOpenType = null;
                return null;
            }

            if (unwrappedType.Kind != GraphQlTypeKind.List)
            {
                type = type.OfType;
                break;
            }

            nullableSymbols.Add(type.OfType.Kind == GraphQlTypeKind.NonNull ? String.Empty : AddQuestionMarkIfNullableReferencesEnabled(String.Empty));
            type = unwrappedType;
        }

        nullableSymbols.Reverse();

        netCollectionOpenType =
            levels == 1
                ? "ICollection<{0}>"
                : String.Concat(Enumerable.Repeat("IList<", levels).Concat(new[] { "{0}" }).Concat(nullableSymbols.Select(s => ">" + s)));

        return type;
    }

    private string WriteDirectiveParameterList(GraphQlSchema schema, IEnumerable<QueryBuilderParameterDefinition> argumentDefinitions, GraphQlDirectiveLocation directiveLocation, TextWriter writer)
    {
        var argumentNames = new HashSet<string>(argumentDefinitions.Select(ad => ad.NetParameterName));
        var directiveParameterNames = new List<string>();

        foreach (var directive in schema.Directives.Where(d => d.Locations.Contains(directiveLocation)))
        {
            var csharpDirectiveName = NamingHelper.ToPascalCase(directive.Name);
            var directiveClassName = csharpDirectiveName + "Directive";
            var directiveParameterName = NamingHelper.LowerFirst(csharpDirectiveName);

            if (argumentNames.Contains(directiveParameterName))
            {
                directiveParameterName += "Directive";

                if (argumentNames.Contains(directiveParameterName))
                {
                    directiveParameterName += "Value";

                    var parameterCounter = 0;
                    var directiveParameterNameWithCounter = directiveParameterName;
                    while (argumentNames.Contains(directiveParameterNameWithCounter))
                        directiveParameterNameWithCounter = directiveParameterName + ++parameterCounter;

                    directiveParameterName = directiveParameterNameWithCounter;
                }
            }

            directiveParameterNames.Add(directiveParameterName);

            writer.Write(", ");
            writer.Write(AddQuestionMarkIfNullableReferencesEnabled(directiveClassName));
            writer.Write(" ");
            writer.Write(directiveParameterName);
            writer.Write(" = null");
        }

        return
            directiveParameterNames.Any()
                ? $"new {AddQuestionMarkIfNullableReferencesEnabled("GraphQlDirective")}[] {{ {String.Join(", ", directiveParameterNames)} }}"
                : "null";
    }

    private static void WriteQueryBuilderMethodBody(bool requiresFullBody, string indentation, TextWriter writer, Action writeBody)
    {
        if (requiresFullBody)
        {
            writer.WriteLine();
            writer.Write(indentation);
            writer.WriteLine("    {");
        }
        else
            writer.Write(" => ");

        writeBody();

        if (requiresFullBody)
        {
            writer.Write(indentation);
            writer.WriteLine("    }");
        }
    }

    private void WriteOverrideProperty(string accessibility, string propertyType, string propertyName, string propertyValue, string indentation, TextWriter writer)
    {
        writer.Write(indentation);
        writer.Write("    ");
        writer.Write(accessibility);
        writer.Write(" override ");
        writer.Write(propertyType);
        writer.Write(" ");
        writer.Write(propertyName);
        writer.Write(" { get");

        if (_configuration.CSharpVersion == CSharpVersion.Compatible)
        {
            writer.Write(" { return ");
            writer.Write(propertyValue);
            writer.WriteLine("; } } ");
        }
        else
        {
            writer.Write("; } = ");
            writer.Write(propertyValue);
            writer.WriteLine(";");
        }

        writer.WriteLine();
    }

    private QueryBuilderParameterDefinition BuildMethodParameterDefinition(GenerationContext context, GraphQlType baseType, GraphQlArgument argument, string netParameterName)
    {
        var argumentType = argument.Type;
        var isArgumentNotNull = argumentType.Kind == GraphQlTypeKind.NonNull;
        var isTypeNotNull = isArgumentNotNull;
        var unwrappedType = argumentType.UnwrapIfNonNull();
        var isCollection = unwrappedType.Kind == GraphQlTypeKind.List;
        if (isCollection)
        {
            isTypeNotNull = unwrappedType.OfType.Kind == GraphQlTypeKind.NonNull;
            argumentType = unwrappedType.OfType;
            unwrappedType = argumentType.UnwrapIfNonNull();
        }

        var argumentTypeDescription =
            unwrappedType.Kind == GraphQlTypeKind.Enum
                ? ConvertToTypeDescription($"{_configuration.ClassPrefix}{NamingHelper.ToPascalCase(unwrappedType.Name)}{_configuration.ClassSuffix}?")
                : ScalarToNetType(baseType, argument.Name, argumentType);
            
        var argumentNetType = argumentTypeDescription.NetTypeName;
            
        if (isTypeNotNull)
            argumentNetType = argumentNetType.TrimEnd('?');

        var isInputObject = unwrappedType.Kind == GraphQlTypeKind.InputObject;
        if (isInputObject)
        {
            argumentNetType = GetCSharpClassName(context, unwrappedType.Name);
            argumentNetType = $"{_configuration.ClassPrefix}{argumentNetType}{_configuration.ClassSuffix}";
                
            if (!isTypeNotNull)
                argumentNetType = AddQuestionMarkIfNullableReferencesEnabled(argumentNetType);
        }

        argumentNetType = isCollection ? $"QueryBuilderParameter<IEnumerable<{argumentNetType}>>" : $"QueryBuilderParameter<{argumentNetType}>";

        if (!isArgumentNotNull)
            argumentNetType = AddQuestionMarkIfNullableReferencesEnabled(argumentNetType);

        var argumentDefinition = $"{argumentNetType} {netParameterName}";
        if (!isArgumentNotNull)
            argumentDefinition += " = null";

        return
            new QueryBuilderParameterDefinition
            {
                Argument = argument,
                NetParameterName = netParameterName,
                NetParameterDefinitionClause = argumentDefinition,
                FormatMask = argumentTypeDescription.FormatMask
            };
    }

    private static void ValidateClassName(string className)
    {
        if (!CSharpHelper.IsValidIdentifier(className))
            throw new InvalidOperationException($"Resulting class name \"{className}\" is not valid. ");
    }

    private static void AppendArgumentDictionary(string indentation, TextWriter writer, ICollection<QueryBuilderParameterDefinition> argumentDefinitions, string argumentCollectionVariableName)
    {
        if (argumentDefinitions.Count == 0)
            return;

        writer.Write(indentation);
        writer.Write("        var ");
        writer.Write(argumentCollectionVariableName);
        writer.WriteLine(" = new List<QueryBuilderArgumentInfo>();");

        static void WriteAddKeyValuePair(TextWriter writer, QueryBuilderParameterDefinition argumentDefinition, string variableName)
        {
            var argument = argumentDefinition.Argument;
            writer.Write(variableName);
            writer.Write(".Add(new QueryBuilderArgumentInfo { ArgumentName = \"");
            writer.Write(argument.Name);
            writer.Write("\", ArgumentValue = ");
            writer.Write(argumentDefinition.NetParameterName);

            if (!String.IsNullOrEmpty(argumentDefinition.FormatMask))
            {
                writer.Write(", FormatMask = \"");
                writer.Write(argumentDefinition.FormatMask.Replace("\"", "\\\""));
                writer.Write("\"");
            }

            writer.WriteLine("} );");
        }

        foreach (var argumentDefinition in argumentDefinitions)
        {
            writer.Write(indentation);

            if (argumentDefinition.Argument.Type.Kind == GraphQlTypeKind.NonNull)
            {
                writer.Write("        ");
                WriteAddKeyValuePair(writer, argumentDefinition, argumentCollectionVariableName);
            }
            else
            {
                writer.Write("        if (");
                writer.Write(argumentDefinition.NetParameterName);
                writer.WriteLine(" != null)");
                writer.Write(indentation);
                writer.Write("            ");
                WriteAddKeyValuePair(writer, argumentDefinition, argumentCollectionVariableName);
                writer.WriteLine();
            }
        }
    }

    private void GenerateEnum(GenerationContext context, GraphQlType type)
    {
        var enumName = _configuration.ClassPrefix + NamingHelper.ToPascalCase(type.Name) + _configuration.ClassSuffix;
            
        context.BeforeEnumGeneration(enumName);
            
        var writer = context.Writer;

        GenerateCodeComments(writer, type.Description, context.Indentation);
        var indentation = GetIndentation(context.Indentation);
        writer.Write(indentation);
        writer.Write("public enum ");
        writer.WriteLine(enumName);
        writer.Write(indentation);
        writer.WriteLine("{");

        var enumValues = type.EnumValues.ToList();
        for (var i = 0; i < enumValues.Count; i++)
        {
            var enumValue = enumValues[i];
            GenerateCodeComments(writer, enumValue.Description, context.Indentation + 4);
            writer.Write(indentation);
            writer.Write("    ");

            var useCSharpNaming = _configuration.EnumValueNaming == EnumValueNamingOption.CSharp;
            var netIdentifier =
                useCSharpNaming
                    ? NamingHelper.ToCSharpEnumName(enumValue.Name)
                    : NamingHelper.ToValidCSharpName(enumValue.Name);

            if (useCSharpNaming && netIdentifier != enumValue.Name)
                writer.Write($"[EnumMember(Value = \"{enumValue.Name}\")] ");

            writer.Write(netIdentifier);

            if (i < enumValues.Count - 1)
                writer.Write(",");

            writer.WriteLine();
        }

        writer.Write(indentation);
        writer.WriteLine("}");

        context.AfterEnumGeneration(enumName);
    }

    private static readonly HashSet<GraphQlDirectiveLocation> SupportedDirectiveLocations =
        new()
        {
            GraphQlDirectiveLocation.Object,
            GraphQlDirectiveLocation.Field,
            GraphQlDirectiveLocation.Query,
            GraphQlDirectiveLocation.Mutation,
            GraphQlDirectiveLocation.Subscription
        };

    private void GenerateDirectives(GenerationContext context)
    {
        if (IsQueryBuilderGenerationDisabled(context.ObjectTypes))
            return;

        var queryBuilderDirectives = context.Schema.Directives.Where(t => SupportedDirectiveLocations.Overlaps(t.Locations)).ToList();
        if (!queryBuilderDirectives.Any())
            return;

        context.BeforeDirectivesGeneration();

        queryBuilderDirectives.ForEach(d => GenerateDirective(context, d));

        context.AfterDirectivesGeneration();
    }

    private void GenerateDirective(GenerationContext context, GraphQlDirective directive)
    {
        var directiveName = NamingHelper.ToPascalCase(directive.Name) + "Directive";

        context.BeforeDirectiveGeneration(directiveName);

        var writer = context.Writer;

        GenerateCodeComments(writer, directive.Description, context.Indentation);

        var orderedArgumentDefinitions = ResolveParameterDefinitions(context, null, directive.Args.OrderByDescending(a => a.Type.Kind == GraphQlTypeKind.NonNull));
        var argumentList = String.Join(", ", orderedArgumentDefinitions.Select(d => d.NetParameterDefinitionClause));

        var indentation = GetIndentation(context.Indentation);
        writer.Write(indentation);
        writer.Write("public class ");
        writer.Write(directiveName);
        writer.WriteLine(" : GraphQlDirective");
        writer.Write(indentation);
        writer.WriteLine("{");
        writer.Write(indentation);
        writer.Write("    public ");
        writer.Write(directiveName);
        writer.Write("(");
        writer.Write(argumentList);
        writer.Write(") : base(\"");
        writer.Write(directive.Name);
        writer.WriteLine("\")");
        writer.Write(indentation);
        writer.WriteLine("    {");

        foreach (var definition in orderedArgumentDefinitions)
        {
            writer.Write(indentation);
            writer.Write("        AddArgument(\"");
            writer.Write(definition.Argument.Name);
            writer.Write("\", ");
            writer.Write(definition.NetParameterName);
            writer.WriteLine(");");
        }

        writer.Write(indentation);
        writer.WriteLine("    }");
        writer.Write(indentation);
        writer.WriteLine("}");

        context.AfterDirectiveGeneration(directiveName);
    }

    private void GenerateCodeComments(TextWriter writer, string description, int indentationSize)
    {
        if (String.IsNullOrWhiteSpace(description))
            return;

        var indentation = GetIndentation(indentationSize);

        if (_configuration.CommentGeneration.HasFlag(CommentGenerationOption.CodeSummary))
        {
            writer.Write(indentation);
            writer.WriteLine("/// <summary>");
            writer.Write(indentation);
            writer.WriteLine("/// " + String.Join(Environment.NewLine + indentation + "/// ", description.Split('\n').Select(l => l.Trim())));
            writer.Write(indentation);
            writer.WriteLine("/// </summary>");
        }

        if (_configuration.CommentGeneration.HasFlag(CommentGenerationOption.DescriptionAttribute))
        {
            writer.Write(indentation);
            writer.WriteLine($"[Description(@\"{description.Replace("\"", "\"\"")}\")]");
        }
    }

    private bool IsUnknownObjectScalar(GraphQlType baseType, string valueName, GraphQlFieldType fieldType)
    {
        if (fieldType.UnwrapIfNonNull().Kind != GraphQlTypeKind.Scalar)
            return false;

        var netType = ScalarToNetType(baseType, valueName, fieldType).NetTypeName;
        return netType == "object" || netType.TrimEnd().EndsWith("System.Object") || netType == "object?" || netType.TrimEnd().EndsWith("System.Object?");
    }

    private ScalarFieldTypeDescription ScalarToNetType(GraphQlType baseType, string valueName, GraphQlFieldType valueType) =>
        valueType.UnwrapIfNonNull().Name switch
        {
            GraphQlTypeBase.GraphQlTypeScalarInteger => GetIntegerNetType(baseType, valueType, valueName),
            GraphQlTypeBase.GraphQlTypeScalarString => GetCustomScalarNetType(baseType, valueType, valueName),
            GraphQlTypeBase.GraphQlTypeScalarFloat => GetFloatNetType(baseType, valueType, valueName),
            GraphQlTypeBase.GraphQlTypeScalarBoolean => ConvertToTypeDescription(GetBooleanNetType(baseType, valueType, valueName)),
            GraphQlTypeBase.GraphQlTypeScalarId => GetIdNetType(baseType, valueType, valueName),
            _ => GetCustomScalarNetType(baseType, valueType, valueName)
        };

    private ScalarFieldTypeDescription GetCustomScalarNetType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName)
    {
        if (_configuration.ScalarFieldTypeMappingProvider is null)
            throw new InvalidOperationException($"'{nameof(_configuration.ScalarFieldTypeMappingProvider)}' missing");

        var typeDescription = _configuration.ScalarFieldTypeMappingProvider.GetCustomScalarFieldType(_configuration, baseType, valueType, valueName);
        if (String.IsNullOrWhiteSpace(typeDescription.NetTypeName))
            throw new InvalidOperationException($".NET type for '{baseType.Name}.{valueName}' ({valueType.Name}) cannot be resolved. Please check {nameof(_configuration)}.{nameof(_configuration.ScalarFieldTypeMappingProvider)} implementation. ");

        if (typeDescription.FormatMask is not null && String.IsNullOrWhiteSpace(typeDescription.FormatMask))
            throw new InvalidOperationException("invalid format mask");

        return typeDescription;
    }

    private static ScalarFieldTypeDescription ConvertToTypeDescription(string netTypeName) => new() { NetTypeName = netTypeName };

    private struct QueryBuilderParameterDefinition
    {
        public GraphQlArgument Argument;
        public string NetParameterName;
        public string NetParameterDefinitionClause;
        public string FormatMask;
    }
}